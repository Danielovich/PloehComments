---
layout: post
title: "Why trust tests?"
description: "Tests are trustworthy if they are simple and you've seen them fail."
date: 2013-04-02 07:40 UTC
tags: [Unit Testing]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		When I started out with TDD some ten years ago, it was really hard to convince programmers that unit testing was valuable. It's better today, but much software is still produced without test coverage. One of the most common arguments for unit tests is to ask the question: "How do you know that your code works?"
	</p>
	<p>
		That's a darn good question, and one of the best answers is that you should cover the code with automated tests (unit tests).
	</p>
	<p>
		Okay, then: How do you know that your unit tests work?
	</p>
	<p>
		A test watches the correctness of the <a href="http://xunitpatterns.com/SUT.html">SUT</a>, but <a href="http://en.wikipedia.org/wiki/Quis_custodiet_ipsos_custodes%3F">who watches the watchmen?</a> Should you write some more unit tests to test your unit tests? Is it going to be <a href="http://en.wikipedia.org/wiki/Turtles_all_the_way_down">turtles all the way down?</a>
	</p>
	<p>
		Obviously, that's not what we do. Then why do we trust unit tests?
	</p>
	<p>
		I think that there's two different reasons for that:
		<ul>
			<li>They are easy to review</li>
			<li>We've seen them fail</li>
		</ul>
	</p>
	<h3 id="56459bdf934c41a49c4287dbeaa19fa1">
		Review <a href="#56459bdf934c41a49c4287dbeaa19fa1" title="permalink">#</a>
	</h3>
	<p>
		The reason that a lot of code fails to do what you think it does is because it's complicated. Sometimes there's also going to be subtle bugs, but I think that the most common problem is that as the code becomes more involved, it becomes more difficult for you to hold it in your brain. A simple <em>Hello World</em> application is easy to understand. Typical software isn't.
	</p>
	<p>
		Unit tests tend to be a lot simpler. First of all, <a href="http://xunitpatterns.com/Conditional%20Test%20Logic.html">unit tests should be deterministic</a>. This means that there should be a clear path through each test case. In other words, a unit test should have a <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic Complexity</a> of 1.
	</p>
	<p>
		If you follow the <a href="http://c2.com/cgi/wiki?ArrangeActAssert">AAA</a> or <a href="http://xunitpatterns.com/Four%20Phase%20Test.html">Four-Phase Test</a> patterns, keep the Cyclomatic Complexity at 1, keep the total line count down, and use good names, you should have a readable test case. Such test code is easy to review for correctness. If you are Pair Programming, you and your partner review the unit test code as you write it. If you use other review mechanisms (e.g. pull requests), the reviewer can review your unit test code. Even if you have no other person reviewing your code, keeping it simple helps you understand what it is that you do. Ultimately, it can't be <em>more</em> error prone than single-handedly writing production code without tests.
	</p>
	<p>
		Part of the reason why we trust unit tests is because, if written well, they are easy to review for correctness.
	</p>
	<h3 id="0cf7de4f7ad34833a9bd2c1e7d4d7093">
		See the test fail <a href="#0cf7de4f7ad34833a9bd2c1e7d4d7093" title="permalink">#</a>
	</h3>
	<p>
		Deeply ingrained into proper TDD is the Red/Green/Refactor cycle. It's extremely important to see the test fail. Personally, I'm saved by this rule about once a week. I write a test and run it, and much to my surprise it turns out to be a <a href="http://xunitpatterns.com/false%20negative.html">false negative</a>. Although I've been doing TDD for some ten years, this still happens to me regularly, so I think it's one of those rigid rules you should always follow. Seeing the test fail verifies that the test indeed tests <em>something</em>.
	</p>
	<p>
		This is also the reason why, if you don't do TDD, but rather write tests after the fact, it becomes extremely important to follow <a href="http://agileinaflash.blogspot.dk/2009/02/writing-characterization-tests.html">a proper procedure for writing Characterization Tests</a>.
	</p>
	<p>
		Part of the reason that we trust unit tests is that we've seen them fail. It's like <a href="http://en.wikipedia.org/wiki/Double-entry_bookkeeping_system">double-entry bookkeeping</a>. The tests keep the SUT in place, and the SUT makes the tests pass.
	</p>
	<h3 id="b23efe23c1574f2b8ff85fb3c529ec9d">
		Append-only tests <a href="#b23efe23c1574f2b8ff85fb3c529ec9d" title="permalink">#</a>
	</h3>
	<p>
		Both of the reasons I've provided are focused on the test as it's being created. At that time, you see it fail and you review it for correctness. As time goes by, you should end up with a test suite with lots of tests. Do you ever look at those tests?
	</p>
	<p>
		You trust them because they were correct <em>when they were created</em>. Are they still correct today?
	</p>
	<p>
		Well, they probably are if you never again touched them, but every time you modify a test case, you make it just a little less trustworthy. Similar in spirit to the <a href="http://en.wikipedia.org/wiki/Open/closed_principle">Open/Closed Principle</a>, a test suite should be open for extension, but closed for modification. Trustworthy test suites are append-only.
	</p>
</div>