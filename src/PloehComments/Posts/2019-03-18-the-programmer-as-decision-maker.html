---
layout: post
title: "The programmer as decision maker"
description: "As a programmer, your job is to make technical decisions. Make some more."
date: 2019-03-18 7:44 UTC
tags: [Productivity]
image: "/content/binary/small-vs-big-decisions-gradient.png"
image_alt: "A spectrum of decisions from small to the left to big to the right."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		When <a href="/schedule">I speak at conferences</a>, people often come and talk to me. (I welcome that, BTW.) Among all the conversations I've had over the years, there's a pattern to some of them. The attendee will start by telling me how inspired (s)he is by the talk I just gave, or something I've written. That's gratifying, and a good way to start a conversation, but is often followed up like this:
	</p>
	<p>
		<strong>Attendee:</strong> "I just wish that we could do something like that in our organisation..."
	</p>
	<p>
		Let's just say that here we're talking about test-driven development, or perhaps just unit testing. Nothing too controversial. I'd typically respond,
	</p>
	<p>
		<strong>Me:</strong> "Why can't you?"
	</p>
	<p>
		<strong>Attendee:</strong> "Our boss won't let us..."
	</p>
	<p>
		That's unfortunate. If your boss has explicitly forbidden you to write and run unit tests, then there's not much you can do. Let me make this absolutely clear: I'm not going on record saying that you should actively disobey a direct order (unless it's unethical, that is). I do wonder, however:
	</p>
	<p>
		<em>Why is the boss even involved in that decision?</em>
	</p>
	<p>
		It seems to me that programmers often defer too much authority to their managers.
	</p>
	<h3 id="510367ded1ca47e7922b540d2fff50b0">
		A note on culture <a href="#510367ded1ca47e7922b540d2fff50b0" title="permalink">#</a>
	</h3>
	<p>
		I'd like to preface the rest of this article with my own context. I've spent most of my programming career in Danish organisations. Even when I worked for Microsoft, I worked for Danish subsidiaries, with Danish managers.
	</p>
	<p>
		The power distance in Denmark is (in)famously short. It's not unheard of for individual contributors to question their superiors' decisions; sometimes to their face, and sometimes even when other people witness this. When done respectfully (which it often is), this can be extremely efficient. Managers are as fallible as the rest of us, and often their subordinates know of details that could impact a decision that a manager is about to make. Immediately discussing such details can help ensure that good decisions are made, and bad decisions are cancelled.
	</p>
	<p>
		This helps managers make better decisions, so enlightened managers welcome feedback.
	</p>
	<p>
		In general, Danish employees also tend to have a fair degree of autonomy. What I'll suggest in this article is unlikely to get you fired in Denmark. Please use your own judgement if you consider transplanting the following to your own culture.
	</p>
	<h3 id="eaa896ed8a6240729301c54fed859ab7">
		Technical decisions <a href="#eaa896ed8a6240729301c54fed859ab7" title="permalink">#</a>
	</h3>
	<p>
		If your job is <em>programmer</em>, <em>software developer</em>, or similar, the value you add to the team is that you bring <em>technical expertise</em>. Maybe some of your colleagues are programmers as well, but together, you are the people with the technical expertise.
	</p>
	<p>
		Even if the project manager or other superiors used to program, unless they're also writing code for the current code base, they only have general technical expertise, but not specific expertise related to the code base you're working with. The people with most technical expertise are you and your colleagues.
	</p>
	<p>
		You are decision makers.
	</p>
	<p>
		Whenever you interact with your code base, you make technical decisions.
	</p>
	<p>
		In order to handle incoming HTTP requests to a <code>/reservations</code> resource, you may first decide to create a <a href="/2019/02/11/asynchronous-injection">new file called <code>ReservationsController.cs</code></a>. You'd most likely also decide to open that file and start adding code to it.
	</p>
	<p>
		Perhaps you add a method called <code>Post</code> that takes a <code>Reservation</code> argument. Perhaps you decide to inject an <code>IMa√ÆtreD</code> dependency.
	</p>
	<p>
		At various steps along the way, you may decide to compile the code.
	</p>
	<p>
		Once you think that you've made enough changes to address your current work item, you may decide to run the program to see if it works. For a web-based piece of software, that typically involves starting up a browser and somehow interacting with the service. If your program is a web site, you may start at the front page, log in, click around, and fill in some forms. If your program is a REST API, you may interact with it via Fiddler or Postman (I prefer curl or <a href="https://github.com/ploeh/Furl">Furl</a>, but most people I've met still prefer something they can click on, it seems).
	</p>
	<p>
		What often happens is that your changes don't work the first time around, so you'll have to troubleshoot. Perhaps you decide to use a debugger.
	</p>
	<p>
		How many decisions are that?
	</p>
	<p>
		I just described seven or eight types of the sort of decisions you make as a programmer. You make such decisions all the time. Do you ask your managers permission before you start a debugging session? Before you create a new file? Before you name a variable?
	</p>
	<p>
		Of course you don't. You're the technical expert. There's no-one better equipped than you or your team members to make those decisions.
	</p>
	<h3 id="bed169525ccf4a90aaa9c0e33fcbf8d0">
		Decide to add unit tests <a href="#bed169525ccf4a90aaa9c0e33fcbf8d0" title="permalink">#</a>
	</h3>
	<p>
		If you want to add unit tests, why don't you just decide to add them? If you want to apply test-driven development, why don't you just do so?
	</p>
	<p>
		A unit test is one or more code files. You're already authorised to make decisions about adding files.
	</p>
	<p>
		You can run a test suite instead of launching the software every time you want to interact with it. It's likely to be faster, even.
	</p>
	<p>
		Why should you ask permission to do that?
	</p>
	<h3 id="e42aac76e52141e68a0bc08fefa56a9b">
		Decide to refactor <a href="#e42aac76e52141e68a0bc08fefa56a9b" title="permalink">#</a>
	</h3>
	<p>
		Another complaint I hear is that people aren't allowed to refactor.
	</p>
	<p>
		Why are you even asking permission to refactor?
	</p>
	<p>
		<a href="http://amzn.to/YPdQDf">Refactoring</a> means reorganising the code without changing the behaviour of the system. Another word for that is <em>editing</em> the code. It's okay. You're already permitted to edit code. It's part of your job description.
	</p>
	<p>
		I think I know what the underlying problem is, though...
	</p>
	<h3 id="f8c290ef29bd437daf2a81b3e06e131c">
		Make technical decisions in the small <a href="#f8c290ef29bd437daf2a81b3e06e131c" title="permalink">#</a>
	</h3>
	<p>
		As an individual contributor, you're empowered to make small-scale technical decisions. These are decisions that are unlikely to impact schedules or allocation of programmers, including new hires. Big decisions probably should involve your manager.
	</p>
	<p>
		I have an inkling of why people feel that they need permission to refactor. It's because the refactoring they have in mind is going to take weeks. Weeks in which nothing else can be done. Weeks where perhaps the code doesn't even compile.
	</p>
	<p>
		Many years ago (but not as many as I'd like it to be), my colleague and I had what Eric Evans in <a href="http://amzn.to/WBCwx7">DDD</a> calls a <em>breakthrough</em>. We wanted to refactor towards deeper insight. What prompted the insight was a new feature that we had to add, and we'd been throwing design ideas back and forth for some time before the new insight arrived.
	</p>
	<p>
		We could implement the new feature if we changed one of the core abstractions in our domain model, but it required substantial changes to the existing code base. We informed our manager of our new insight and our plan, estimating that it would take less than a week to make the changes and implement the new feature. Our manager agreed with the plan.
	</p>
	<p>
		Two weeks later our code hadn't been in a compilable state for a week. Our manager pulled me away to tell me, quietly and equitably, that he was not happy with our lack of progress. I could only concur.
	</p>
	<p>
		After more heroic work, we finally managed to complete the changes and implement the new feature. Nonetheless, blocking all other development for two-three weeks in order to make a change isn't acceptable.
	</p>
	<p>
		That sort of change is a big decision because it impacts other team members, schedules, and perhaps overall business plans. Don't make those kinds of decisions without consulting with stakeholders.
	</p>
	<p>
		This still leaves, I believe, lots of room for individual decision-making in the small. What I learned from the experience I just recounted was not to engage in big changes to a code base. Learn how to make multiple incremental changes instead. In case that's completely impossible, add the new model side-by-side with the old model, and incrementally change over. That's what I should have done those many years ago.
	</p>
	<h3 id="298ca23885544e5f906379c1a6d15586">
		Don't be sneaky <a href="#298ca23885544e5f906379c1a6d15586" title="permalink">#</a>
	</h3>
	<p>
		When I give talks about the blessings of functional programming, I sometimes get into another type of discussion.
	</p>
	<p>
		<strong>Attendee:</strong> It's so inspiring how beautiful and simple complex domain models become in <a href="https://fsharp.org">F#</a>. How can we do the same in C#?
	</p>
	<p>
		<strong>Me:</strong> You can't. If you're already using C#, you should strongly consider F# if you wish to do functional programming. Since it's also a .NET language, you can gradually introduce F# code and mix the compiled code with your existing C# code.
	</p>
	<p>
		<strong>Attendee:</strong> Yes... [already getting impatient with me] But we can't do that...
	</p>
	<p>
		<strong>Me:</strong> Why not?
	</p>
	<p>
		<strong>Attendee:</strong> Because our manager will not allow it.
	</p>
	<p>
		Based on the suggestions I've already made here, you may expect me to say that that's another technical decision that you should make without asking permission. Like the previous example about blocking refactorings, however, this is another large-scale decision.
	</p>
	<p>
		Your manager may be concerned that it'd be hard to find new employees if the code base is written in some niche language. <a href="/2015/12/03/the-rules-of-attraction-language">I tend to disagree with that position</a>, but I do understand why a manager would take that position. While I think it suboptimal to restrict an entire development organisation to a single language (whether it's C#, Java, C++, Ruby, etc.), I'll readily accept that language choice is a strategic decision.
	</p>
	<p>
		If every programmer got to choose the programming language they prefer the most that day, you'd have code bases written in dozens of different languages. While you can train bright new hires to learn a new language or two, it's unrealistic that a new employee will be able to learn thirty different languages in a short while.
	</p>
	<p>
		I find it reasonable that a manager has the final word on the choice of language, even when I often disagree with the decisions.
	</p>
	<p>
		The outcome usually is that people are stuck with C# (or Java, or...). Hence the question: <em>How can we do functional programming in C#?</em>
	</p>
	<p>
		I'll give the answer that I often give here on the blog: <a href="https://en.wikipedia.org/wiki/Mu_(negative)">mu</a> (<em>unask the question</em>). You can, in fact, translate functional concepts to C#, but <a href="/2018/07/24/dependency-injection-revisited">the result is so non-idiomatic</a> that only the syntax remains of C#:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IReservationsInstruction</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;Select&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">IReservationsInstruction</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;source,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;selector)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;source.Match&lt;<span style="color:#2b91af;">IReservationsInstruction</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isReservationInFuture:&nbsp;t&nbsp;=&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">IsReservationInFuture</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:#2b91af;">Reservation</span>,&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">bool</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.Item1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&gt;&nbsp;selector(t.Item2(b)))),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readReservations:&nbsp;t&nbsp;=&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ReadReservations</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:#2b91af;">DateTimeOffset</span>,&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">IReadOnlyCollection</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.Item1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&gt;&nbsp;selector(t.Item2(d)))),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create:&nbsp;t&nbsp;=&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Create</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:#2b91af;">Reservation</span>,&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.Item1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&gt;&nbsp;selector(t.Item2(r)))));
}</pre>
	</p>
	<p>
		Keep in mind the manager's motivation for standardising on C#. It's often related to concerns about being able to hire new employees, or move employees from project to project.
	</p>
	<p>
		If you write 'functional' C#, you'll end up with code like the above, or the following real-life example:
	</p>
	<p>
		<pre><span style="color:blue;">return</span>&nbsp;<span style="color:blue;">await</span>&nbsp;sendRequest(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">ApiMethodNames</span>.InitRegistration,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">GSObject</span>())
&nbsp;&nbsp;&nbsp;&nbsp;.Map(r&nbsp;=&gt;&nbsp;<span style="color:#2b91af;">ValidateResponse</span>.Validate(r)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.MapFailure(_&nbsp;=&gt;&nbsp;<span style="color:#2b91af;">ErrorResponse</span>.RegisterErrorResponse()))
&nbsp;&nbsp;&nbsp;&nbsp;.Bind(r&nbsp;=&gt;&nbsp;r.RetrieveField(<span style="color:#a31515;">&quot;regToken&quot;</span>))
&nbsp;&nbsp;&nbsp;&nbsp;.BindAsync(token&nbsp;=&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendRequest(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">ApiMethodNames</span>.RegisterAccount,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateRegisterRequest(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mailAddress,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;password,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Map(<span style="color:#2b91af;">ValidateResponse</span>.Validate)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Bind(response&nbsp;=&gt;&nbsp;getIdentity(response)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ToResult(<span style="color:#2b91af;">ErrorResponse</span>.ExternalServiceResponseInvalid)))
&nbsp;&nbsp;&nbsp;&nbsp;.Map(id&nbsp;=&gt;&nbsp;<span style="color:#2b91af;">GigyaIdentity</span>.CreateNewSiteUser(id.UserId,&nbsp;mailAddress));</pre>
	</p>
	<p>
		(I'm indebted to <a href="https://twitter.com/runeibsen">Rune Ibsen</a> for this example.)
	</p>
	<p>
		A new hire can have ten years of C# experience and still have no chance in a code base like that. You'll first have to teach him or her functional programming. If you can do that, you might as well also teach a new language, like F#.
	</p>
	<p>
		It's my experience that learning the syntax of a new language is easy, and usually doesn't take much time. The hard part is learning a new way to think.
	</p>
	<p>
		Writing 'functional' C# makes it doubly hard on new team members. Not only do they have to learn a new paradigm (functional programming), but they have to learn it in a language unsuited for that paradigm.
	</p>
	<p>
		That's why I think you should unask the question. If your manager doesn't want to allow F#, then writing 'functional' C# is just being sneaky. That'd be obeying the letter of the law while breaking the spirit of it. That is, in my opinion, immoral. Don't be sneaky.
	</p>
	<h3 id="2f1b38953bbc4814994ee471caf4c5ac">
		Summary <a href="#2f1b38953bbc4814994ee471caf4c5ac" title="permalink">#</a>
	</h3>
	<p>
		As a professional programmer, your job is to be a technical expert. In normal circumstances (at least the ones I know from my own career), you have agency. In order to get anything done, you make small decisions all the time, such as editing code. That's not only okay, but expected of you.
	</p>
	<p>
		Some decision, on the other hand, can have substantial ramifications. Choosing to write code in an unsanctioned language tends to fall on the side where a manager should be involved in the decision.
	</p>
	<p>
		In between is a grey area.
	</p>
	<p>
		<img src="/content/binary/small-vs-big-decisions-gradient.png" alt="A spectrum of decisions from small to the left to big to the right.">
	</p>
	<p>
		I don't even consider adding unit tests to be in the grey area, but some refactorings may be.
		<blockquote>
			<p>"It's easier to ask forgiveness than it is to get permission."</p>
			<footer><cite>Grace Hopper</cite></footer>
		</blockquote>
	</p>
	<p>
		To navigate grey areas you need a moral compass.
	</p>
	<p>
		I'll let you be the final judge of what you can get away with, but I consider it both appropriate and ethical to make the decision to add unit tests, and to continually improve code bases. You shouldn't have to ask permission to do that.
	</p>
</div>
<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>

 	<div class="comment" id="dd2ab8d5dc6e4c5f9e49d7d7f35a8759">
		<div class="comment-author"><a href="https://github.com/chicocode">Francisco Berrocal</a></div>
		<div class="comment-content">
            <p>Before all, I'd just like to thank all the content you share, they all make me think in a good way!</p>
            <p>
              Now regarding to this post, while I tend to agree that a developer can take the decision to add (or not)
              unit tests by himself, there is no great value comming out of it, if that's not an approach of the whole development team, right? I believe we need the entire team on board to maximize the values of unit tests. There are changes we need to consider, from changes in the mindset of how you develop to actually running them on continuour integration pipelines. Doesn't all of that push simple decisions like "add unit test" from green area towards orange area?
            </p>
		</div>
		<div class="comment-date">2019-03-18 13:14 UTC</div>
	</div>

	<div class="comment" id="2bc69a5123d8499ca40631b9ce946919">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Francisco, thank you for writing. If you have a team of developers, then I agree that unit tests are going to be most valuable if the team decides to use them.
			</p>
			<p>
				This is still something that you ought to be competent to decide as a self-organising team of developers. Do you need to ask a manager's permission?
			</p>
			<p>
				I'm not trying to pretend that this is easy. I realise that it can be difficult.
			</p>
			<p>
				I've heard about teams where other developers are hostile to the idea of unit testing. In that situation, I can offer no easy fixes. What a lone developer can try to do in that situation is to add and run unit tests locally, on his or her own machine. This will incur some friction, because other team members will be oblivious to the tests, so they'll change code that will cause those unit tests to break.
			</p>
			<p>
				This might teach the lone developer to write tests so that they're as robust to trivial changes as possible. That's a valuable skill in any case. There's still going to be some overhead of maintaining the unit tests in a scenario like that, but if that overhead is smaller than the productivity gained, then in might still be worthwhile.
			</p>
			<p>
				What might then happen could be that other developers who are on the fence see that the lone unit tester is more effective than they are. Perhaps they'll get curious about unit tests after all, once they can see the contours of advantages.
			</p>
			<p>
				The next scenario, then, is a team with a few developers writing unit tests, and other who don't. At some number, you'll have achieved enough critical mass that, at least, you get to check in the unit tests together with the source code. Soon after, you may be able to institute a policy that while not everyone writes unit tests, it's not okay to break existing tests.
			</p>
			<p>
				The next thing you can do, then, is to set up a test run as part of continuous integration and declare that a failing test run means that the build broke. You still have team members who don't write tests, but at least you get to do it, and the tests add value to the whole team.
			</p>
			<p>
				Perhaps the sceptics will slowly start to write unit tests over time. Some die-hards probably never will.
			</p>
			<p>
				You may be able to progress through such stages without asking a manager, but I do understand that there's much variation in organisation and team dynamics. If you can use any of the above sketches as inspiration, then that's great. If you (or other readers) have other success stories to tell, then please share them.
			</p>
			<p>
				The point I was trying to make with this article is that programmers have agency. This isn't a licence to do whatever you please. You still have to navigate the dynamics of whatever organisation you're in. You may not, however, need to ask your manager about every little thing that you're competent to decide yourselves.
			</p>
		</div>
		<div class="comment-date">2019-03-19 7:57 UTC</div>
	</div>

	<div class="comment">
		<div class="comment-author"><a href="https://hettomei.github.io/">Timoth√©e GAUTHIER</a></div>
		<div class="comment-content">
			<p>
				Thank you A LOT for putting words on all these thought. You'll be my reference whenever I want to introduce unit test.
			</p>
			<p>
				My usual example is "a surgeon doesn't need to ask to the manager if he can wash his hand. Whashing his hand is part of his job". (Not mine, but I can't remember where it comes from)
			</p>
		</div>
		<div class="comment-date">2019-03-19 20:15 UTC</div>
	</div>
</div>
