---
layout: post
title: "On trust in software development"
description: "Can you trust your colleagues to write good code? Can you trust yourself?"
date: 2023-03-20 8:55 UTC
tags: [Productivity]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        I've recently noticed a trend among some agile thought leaders. They talk about <em>trust</em> and <em>gatekeeping</em>. It goes something like this:
    </p>
    <blockquote>
        <p>
            Why put up barriers to prevent people from committing code? Don't you trust your colleagues?
        </p>
        <p>
            Gated check-ins, pull requests, reviews are a sign of a dysfunctional organisation.
        </p>
    </blockquote>
    <p>
        I'm deliberately paraphrasing. While I could cite multiple examples, I wish to engage with the idea rather than the people who propose it. Thus, I apologise for the seeming use of <a href="https://en.wikipedia.org/wiki/Weasel_word">weasel words</a> in the above paragraph, but my agenda is the opposite of appealing to anonymous authority.
    </p>
    <p>
        If someone asks me: "Don't you trust your colleagues?", my answer is:
    </p>
    <p>
        No, I don't trust my colleagues, as I don't trust myself.
    </p>
    <h3 id="25501f07623946a1925a83af5b5198a3">
        Framing <a href="#25501f07623946a1925a83af5b5198a3">#</a>
    </h3>
    <p>
        I don't trust myself to write defect-free code. I don't trust that I've always correctly understood the requirements. I don't trust that I've written the code in the best possible way. Why should I trust my colleagues to be superhumanly perfect?
    </p>
    <p>
        The <em>trust</em> framing is powerful because few people like to be labeled as <em>mistrusting</em>. When asked <em>"don't you trust your colleagues?"</em> you don't want to answer in the affirmative. You don't want to come across as suspicious or paranoid. You want to <em>belong</em>.
    </p>
    <p>
        <a href="https://en.wikipedia.org/wiki/Belongingness">The need to belong is fundamental to human nature</a>. When asked if you trust your colleagues, saying "no" implicitly disassociates you from the group.
    </p>
    <p>
        Sometimes the trust framing goes one step further and labels processes such as code reviews or pull requests as <em>gatekeeping</em>. This is still the same framing, but now turns the group dynamics around. Now the question isn't whether <em>you</em> belong, but whether you're excluding others from the group. Most people (me included) want to be nice people, and excluding other people is bullying. Since you don't want to be a bully, you don't want to be a gatekeeper.
    </p>
    <p>
        Framing a discussion about software engineering as one of trust and belonging is powerful and seductive. You're inclined to accept arguments made from that position, and you may not discover the sleight of hand. It's subliminal.
    </p>
    <p>
        Most likely, it's such a fundamental and subconscious part of human psychology that the thought leaders who make the argument don't realise what they are doing. Many of them are professionals that I highly respect; people with more merit, experience, and education than I have. I don't think they're deliberately trying to put one over you.
    </p>
    <p>
        I do think, on the other hand, that this is an argument to be challenged.
    </p>
    <h3 id="1a98f4b52b824194b23b5bb836efacb7">
        Two kinds of trust <a href="#1a98f4b52b824194b23b5bb836efacb7">#</a>
    </h3>
    <p>
        On the surface, the trust framing seems to be about belonging, or its opposite, exclusion. It implies that if you don't trust your co-workers, you suspect them of malign intent. Organisational dysfunction, it follows, is a Hobbesian state of nature where everyone is out for themselves: Expect your colleague to be a back-stabbing liar out to get you.
    </p>
    <p>
        Indeed, the word <em>trust</em> implies that, too, but that's usually not the reason to introduce guardrails and checks to a software engineering process.
    </p>
    <p>
        Rather, another fundamental human characteristic is <em>fallibility</em>. We make mistakes in all sorts of way, and we don't make them from malign intent. We make them because we're human.
    </p>
    <p>
        Do we trust our colleagues to make no mistakes? Do we trust that our colleagues have perfect knowledge of requirement, goals, architecture, coding standards, and so on? I don't, just as I don't trust myself to have those qualities.
    </p>
    <p>
        This interpretation of <em>trust</em> is, I believe, better aligned with software engineering. If we institute formal sign-offs, code reviews, and other guardrails, it's not that we suspect co-workers of ill intent. Rather, we're trying to prevent mistakes.
    </p>
    <h3 id="020b7202b31d421baa9e612ca168f767">
        Two wrongs... <a href="#020b7202b31d421baa9e612ca168f767">#</a>
    </h3>
    <p>
        That's not to say that all guardrails are necessary all of the time. The thought leaders I so vaguely refer to will often present alternatives: Pair programming instead of pull requests. Indeed, that can be an efficient and confidence-inducing way to work, in certain contexts. I describe advantages as well as disadvantages in my book <a href="/2021/06/14/new-book-code-that-fits-in-your-head">Code That Fits in Your Head</a>.
    </p>
    <p>
        I've warned about the <em>trust framing</em>, but that doesn't mean that pull requests, code reviews, gated check-ins, or feature branches are always a good idea. Just because one argument is flawed it does't mean that the message is wrong. It could be correct for other reasons.
    </p>
    <p>
        I agree with the likes of <a href="https://martinfowler.com/">Martin Fowler</a> and <a href="https://www.davefarley.net/">Dave Farley</a> that feature branching is a bad idea, and that you should adopt <a href="https://en.wikipedia.org/wiki/Continuous_delivery">Continuous Delivery</a>. <a href="/ref/accelerate">Accelerate</a> strongly suggests that.
    </p>
    <p>
        I also agree that pull requests and formal reviews with sign-offs, <em>as they're usually practised</em>, is at odds with even <a href="https://en.wikipedia.org/wiki/Continuous_integration">Continuous Integration</a>. Again, be aware of common pitfalls in logic. Just because one way to do reviews is counter-productive, it doesn't follow that all reviews are bad.
    </p>
    <p>
        As I have outlined in another article, under the right circumstances, <a href="/2021/06/21/agile-pull-requests">agile pull requests</a> are possible. I've had good result with pull requests like that. Reviewing was everyone's job, and we integrated multiple times a day.
    </p>
    <p>
        Is that way to work always possible? Is it always the best way to work? No, of course not. Context matters. I've worked with another team where it was evident that that process had little chance of working. On the other hand, that team wasn't keen on pair programming either. Then what do you do?
    </p>
    <h3 id="1c3ff2a877214b76934d3817f24c1318">
        Mistakes were made <a href="#1c3ff2a877214b76934d3817f24c1318">#</a>
    </h3>
    <p>
        I rarely have reason to believe that co-workers have malign intent. When we are working together towards a common goal, I trust that they have as much interest in reaching that goal as I have.
    </p>
    <p>
        Does that trust mean that everyone is free to do whatever they want? Of course not. Even with the best of intentions, we make mistakes, there are misunderstandings, or we have incomplete information.
    </p>
    <p>
        This is one among several reasons I practice test-driven development (TDD). Writing a test before implementation code catches many mistakes early in the process. In this context, the point is that I don't trust myself to be perfect.
    </p>
    <p>
        Even with TDD and the best of intentions, there are other reasons to look at other people's work.
    </p>
    <p>
        Last year, I did some freelance programming for a customer, and sometimes I would receive feedback that a function I'd included in a pull request already existed in the code base. I didn't have that knowledge, but the review caught it.
    </p>
    <p>
        Could we have caught that with pair or ensemble programming? Yes, that would work too. There's more than one way to make things work, and they tend to be context-dependent.
    </p>
    <p>
        If everyone on a team have the luxury of being able to work together, then pair or ensemble programming is an efficient way to coordinate work. Little extra process may be required, because everyone is already on the same page.
    </p>
    <p>
        If team members are less fortunate, or have different preferences, they may need to rely on the <a href="/2023/02/20/a-thought-on-workplace-flexibility-and-asynchrony">flexibility offered by asynchrony</a>. This doesn't mean that you can't do Continuous Delivery, even with pull requests and code reviews, but <a href="/2020/03/16/conways-law-latency-versus-throughput">the trade-offs are different</a>.
    </p>
    <h3 id="8cf2f27540de4461826bfe2b9ef88405">
        Conclusion <a href="#8cf2f27540de4461826bfe2b9ef88405">#</a>
    </h3>
    <p>
        There are many good reasons to be critical of code reviews, pull requests, and other processes that seem to slow things down. The lack of trust in co-workers is, however, not one of them.
    </p>
    <p>
        You can easily be swayed by that argument because it touches something deep in our psyche. We want to be trusted, and we want to trust our colleagues. We want to <em>belong</em>.
    </p>
    <p>
        The argument is visceral, but it misrepresents the motivation for process. We don't review code because we believe that all co-workers are really North Korean agents looking to sneak in security breaches if we look away.
    </p>
    <p>
        We look at each other's work because it's human to make mistakes. If we can't all be in the same office at the same time, fast but asynchronous reviews also work.
    </p>
</div>
<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>

	<div class="comment" id="f2faef409ab74134938a6ae77404ec43">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<p>
				This reminds me of <a href="https://en.wikipedia.org/wiki/Hanlon%27s_razor">Hanlon's razor</a>.
            </p>
            <blockquote>
                Never attribute to malice that which is adequately explained by stupidity.
            </blockquote>
		</div>
		<div class="comment-date">2023-03-23 23:29 UTC</div>
	</div>
	<div class="comment" id="c46f7f22b22941f6a24858a40093424c">
		<div class="comment-author"><a href="mailto:danielfrostdk@outlook.com">Daniel Frost</a></div>
		<div class="comment-content">
			<p>
				Too much technical attibution is still being presented on a whole, into a field which 
				is far more of a social and psycological construct. What's even worse is the evidence around organisation and team capabilities is pretty clear towards what makes a good team and organisation. 
				<br/><br/>
				The technical solutions for reaching trust or beloningness is somewhat a menas to an end. They can't stand alone because it only takes two humans to side track them.
				<br/><br/>
				therefore I still absolutely believe that the technical parts of software engineering is by far the less demanding. As technical work most often still are done as individual contributions
				based on loose requirements, equally loose leadership and often non-existing enforcement from tooling and scattered human ownership. Even worse subjective perceptions. 
				That I believe on the other hand has everything to do with trust, gatekeeping, belonging and other human psycology needs.
            </p>
		</div>
		<div class="comment-date">2023-03-27 11:29 UTC</div>
	</div>	
</div>
