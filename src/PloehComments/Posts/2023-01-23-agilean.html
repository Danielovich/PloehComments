---
layout: post
title: "Agilean"
description: "There are other agile methodologies than scrum."
date: 2023-01-23 7:55 UTC
tags: [Productivity]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		More than twenty years after <a href="https://agilemanifesto.org/">the Agile Manifesto</a> it looks as though there's only one kind of agile process left: <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)">Scrum</a>.
	</p>
	<p>
		I recently held a workshop and as a side remark I mentioned that I don't consider scrum the best development process. This surprised some attendees, who politely inquired about my reasoning.
	</p>
	<h3 id="8837c4f67d694f93ad0b708cc1739705">
		My experience with scrum <a href="#8837c4f67d694f93ad0b708cc1739705" title="permalink">#</a>
	</h3>
	<p>
		The first nine years I worked as a professional programmer, the companies I worked in used various <a href="https://en.wikipedia.org/wiki/Waterfall_model">waterfall</a> processes. When I joined the Microsoft Dynamics Mobile team in 2008 they were already using scrum. That was my first exposure to it, and I liked it. Looking back on it today, we weren't particular dogmatic about the process, being more interested in getting things done.
	</p>
	<p>
		One telling fact is that we took turns being Scrum Master. Every sprint we'd rotate that role.
	</p>
	<p>
		We did test-driven development, and had two-week sprints. This being a Microsoft development organisation, we had a dedicated build master, tech writers, specialised testers, and security reviews.
	</p>
	<p>
		I liked it. It's easily one of the most professional software organisations I've worked in. I think it was a good place to work for many reasons. Scrum may have been a contributing factor, but hardly the only reason.
	</p>
	<p>
		I have no issues with scrum as we practised it then. I recall later attending a presentation by <a href="https://en.wikipedia.org/wiki/Mike_Cohn">Mike Cohn</a> where he outlined four quadrants of team maturity. You'd start with scrum, but use retrospectives to evaluate what worked and what didn't. Then you'd adjust. A mature, self-organising team would arrive at its own process, perhaps initiated with scrum, but now having little resemblance with it.
	</p>
	<p>
		I like scrum when viewed like that. When it becomes rigid and empty ceremony, I don't. If all you do is daily stand-ups, sprints, and backlogs, you may be doing scrum, but probably not agile.
	</p>
	<h3 id="1bb8e521e78341768ca7f5942f3ace4a">
		Continuous deployment <a href="#1bb8e521e78341768ca7f5942f3ace4a" title="permalink">#</a>
	</h3>
	<p>
		After Microsoft I joined a startup so small that formal process was unnecessary. Around that time I also became interested in <a href="https://en.wikipedia.org/wiki/Lean_software_development">lean software development</a>. In the beginning, I learned a lot from <a href="https://www.linkedin.com/in/martin-jul-39a12/">Martin Jul</a> who seemed to use the now-defunct <a href="https://ative.dk/">Ative</a> blog as a public notepad as he was reading works of <a href="https://en.wikipedia.org/wiki/W._Edwards_Deming">Deming</a>. I suppose, if you want a more canonical introduction to the topic, that you might start with one of <a href="http://www.poppendieck.com/">the Poppendiecks'</a> books, but since I've only read <a href="/ref/implementing-lean">Implementing Lean Software Development</a>, that's the only one I can recommend.
	</p>
	<p>
		Around 2014 I returned to a regular customer. The team had, in my absence, been busy implementing <a href="https://en.wikipedia.org/wiki/Continuous_deployment">continuous deployment</a>. Instead of artificial periods like 'sprints' we had a <a href="https://en.wikipedia.org/wiki/Kanban_board">kanban board</a> to keep track of our work. We used a variation of <a href="https://en.wikipedia.org/wiki/Feature_toggle">feature flags</a> and marked features as done when they were complete and in production.
	</p>
	<p>
		Why wait until <em>next</em> Friday if the feature is <em>done, done</em> on a Wednesday? Why wait until the <em>next</em> Monday to identify what to work on next, if you're ready to take on new work on a Thursday? Why not move towards <em>one-piece flow?</em>
	</p>
	<p>
		An effective self-organising team typically already knows what it's doing. Much process is introduced in order to give external stakeholders visibility into what a team is doing.
	</p>
	<p>
		I found, in that organisation, that continuous deployment eliminated most of that need. At one time I asked a stakeholder what he thought of the feature I'd deployed a week before - a feature that <em>he had requested</em>. He replied that he hadn't had time to look at it yet.
	</p>
	<p>
		The usual inquires about status (<em>Is it done yet? When is it done?</em>) were gone. The team moved faster than the stakeholders could keep up. That also gave us <a href="/2022/09/19/when-to-refactor">enough slack to keep the code base in good order</a>. We also used test-driven development throughout (TDD).
	</p>
	<p>
		TDD with continuous deployment and a kanban board strikes me as congenial with the ideas of lean software development, but that's not all.
	</p>
	<h3 id="9f5e725164f54d32b5d56a28d3b1619e">
		Stop-the-line issues <a href="#9f5e725164f54d32b5d56a28d3b1619e" title="permalink">#</a>
	</h3>
	<p>
		An <a href="https://en.wikipedia.org/wiki/Andon_(manufacturing)">andon cord</a> is a central concept in <a href="https://en.wikipedia.org/wiki/Lean_manufacturing">lean manufactoring</a>. If a worker (or anyone, really) discovers a problem during production, he or she pulls the andon cord and <em>stops the production line</em>. Then everyone investigates and determines what to do about the problem. Errors are not allowed to accumulate.
	</p>
	<p>
		I think that I've internalised this notion to such a degree that I only recently connected it to lean software development.
	</p>
	<p>
		In <a href="/2021/06/14/new-book-code-that-fits-in-your-head">Code That Fits in Your Head</a>, I recommend turning compiler warnings into errors at the beginning of a code base. Don't allow warnings to pile up. Do the same with static code analysis and linters.
	</p>
	<p>
		When discussing software engineering with developers, I'm beginning to realise that this runs even deeper.
	</p>
	<ul>
		<li>Turn warnings into errors. Don't allow warnings to accumulate.</li>
		<li>The correct number of unhandled exceptions in production is zero. If you observe an unhandled exception in your production logs, fix it. Don't let them accumulate.</li>
		<li>The correct number of known bugs is zero. Don't let bugs accumulate.</li>
	</ul>
	<p>
		If you're used to working on a code base with hundreds of known bugs, and frequent exceptions in production, this may sound unrealistic. If you deal with issues as soon as they arise, however, this is not only possible - it's faster.
	</p>
	<p>
		In lean software development, bugs are stop-the-line issues. When something unexpected happens, you stop what you're doing and make fixing the problem the top priority. You build quality in.
	</p>
	<p>
		This has been my modus operandi for years, but I only recently connected the dots to realise that this is a typical lean practice. I may have picked it up from there. Or perhaps it's just common sense.
	</p>
	<h3 id="e2513b8e32b148cbab8dbd6b75c67348">
		Conclusion <a href="#e2513b8e32b148cbab8dbd6b75c67348" title="permalink">#</a>
	</h3>
	<p>
		When Agile was new and exciting, there were <a href="https://en.wikipedia.org/wiki/Extreme_programming">extreme programming</a> and scrum, and possibly some lesser known techniques. Lean was around the corner, but didn't come to my attention, at least, until around 2010. Then it seems to have faded away again.
	</p>
	<p>
		Today, agile looks synonymous with scrum, but I find lean software development more efficient. Why divide work into artificial time periods when you can release continuously? Why <em>plan</em> bug fixing when it's more efficient to stop the line and deal with the problem as it arises?
	</p>
	<p>
		That may sound counter-intuitive, but it works because it prevents technical debt from accumulating.
	</p>
	<p>
		Lean software development is, in my experience, a better agile methodology than scrum.
	</p>
</div>