---
layout: post
title: "Diamond kata with FsCheck"
description: "This post is a walk-through of doing the Diamond kata with FsCheck."
date: 2015-01-10 22:10 UTC
tags: [Unit Testing, F#, FsCheck, Property-based Testing]
---
{% include JB/setup %}

<div id="post">
  <p>
    <em>{{ page.description }}</em>
  </p>
  <p>
    Recently, <a href="http://natpryce.com">Nat Pryce</a> tweeted:
    <blockquote>
      <a href="https://twitter.com/natpryce/status/551905182280585216">The diamond kata, TDD'd only with property-based tests. https://github.com/npryce/property-driven-diamond-kata One commit for each step: add test/make test pass/refactor</a>
    </blockquote>
    This made me curious. First, I'd never heard about the <em>Diamond kata</em>, and second, I find Property-Based Testing quite interesting these days.
  </p>
  <p>
    Digging a bit lead me to <a href="http://claysnow.co.uk/recycling-tests-in-tdd">a blog post</a> by <a href="http://claysnow.co.uk/author/sebrose">Seb Rose</a>; the Diamond kata is extremely easy to explain:
    <blockquote>
      <p>
        Given a letter, print a diamond starting with ‘A’ with the supplied letter at the widest point.
      </p>
      <p>
        For example: print-diamond ‘C’ prints
      </p>
      <pre>  A
 B B 
C   C
 B B 
  A  </pre>
    </blockquote>
    After having thought about it a little, I couldn't even begin to see how one could approach this problem using Property-Based Testing. It struck me as a problem inherently suited for Example-Driven Development, so I decided to do that first.
  </p>
  <h3 id="e911864d51774d7f835f955dc199b18d">
    Example-Driven Development <a href="#e911864d51774d7f835f955dc199b18d" title="permalink">#</a>
  </h3>
  <p>
    The no-brain approach to Example-Driven Development is to start with 'A', then 'B', and so on. Exactly as Seb Rose predicts, when you approach the problem like this, when you reach 'C', it no longer seems reasonable to hard-code the responses, but then the entire complexity of the problem hits you all at once. It's quite hard to do incremental development by going through the 'A', 'B', 'C' progression.
  </p>
  <p>
    This annoyed me, but I was curious about the implementation, so I spent an hours or so toying with making the 'C' case pass. After this, on the other hand, I had an implementation that works for all letters A-Z.
  </p>
  <h3 id="77a5caf1aeaf4f878dfc0585d4346366">
    Property-Driven Development <a href="#77a5caf1aeaf4f878dfc0585d4346366" title="permalink">#</a>
  </h3>
  <p>
    On my commute it subsequently struck me that solving the Diamond kata with Example-Driven Development taught me a lot about the problem itsef, and I could easily come up with the first 10 properties about it.
  </p>
  <p>
    Therefore, I decided to give the kata another try, this time with <a href="https://github.com/fsharp/FsCheck">FsCheck</a>. I also wanted to see if it would be possible to make the development more incremental; while I didn't follow the <a href="http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">Transformation Priority Premise</a> (TPP) to the letter, I was inspired by it. My third 'rule' was to use <a href="{{ site.production_url }}/outside-in-tdd">Devil's Advocate</a> to force me to write properties that completely describe the problem.
  </p>
  <h3 id="4c98113dd01641569ae918e2b094f42f">
    Ice Breaker <a href="#4c98113dd01641569ae918e2b094f42f" title="permalink">#</a>
  </h3>
  <p>
    To get started, it can be a good idea to write a simple (ice breaker) test, because there's always a little work involved in getting everything up and running. To meet that goal, I wrote this almost useless property:
  </p>
  <p>
    <pre>[&lt;<span style="color:#2b91af;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;``Diamond&nbsp;is&nbsp;non-empty``&nbsp;(letter&nbsp;:&nbsp;<span style="color:#2b91af;">char</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#2b91af;">Diamond</span>.make&nbsp;letter
&nbsp;&nbsp;&nbsp;&nbsp;not&nbsp;(<span style="color:#2b91af;">String</span>.IsNullOrWhiteSpace&nbsp;actual)</pre>
  </p>
  <p>
    It only states that the string returned from the Diamond.make function isn't an empty string. Using Devil's Advocate, I created this implementation:
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;make&nbsp;letter&nbsp;=&nbsp;<span style="color:#a31515;">&quot;Devil&#39;s&nbsp;advocate.&quot;</span>
</pre>
  </p>
  <p>
    This hard-coded result satisfies the single property. However, the only reason it works is because it ignores the input.
  </p>
  <h3 id="94837c0fd8a046b2b62fa290efe7d968">
    Constraining the input <a href="#94837c0fd8a046b2b62fa290efe7d968" title="permalink">#</a>
  </h3>
  <p>
    The kata only states what should happen for the inputs A-Z, but as currently written, FsCheck will serve all sorts of char values, including white space and funny characters like '&lt;', ']', '?', etc. While I could write a run-time check in the make function, and return <code>None</code> upon invalid input, I am, after all, only doing a kata, so I'd rather want to tell FsCheck to give me only the letters A-Z. Here's one way to do that:
  </p>
  <p>
  <pre><span style="color:blue;">type</span>&nbsp;<span style="color:#2b91af;">Letters</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">member</span>&nbsp;Char()&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Arb</span>.<span style="color:#2b91af;">Default</span>.Char()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Arb</span>.filter&nbsp;(<span style="color:blue;">fun</span>&nbsp;c&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;&lt;=&nbsp;c&nbsp;&amp;&amp;&nbsp;c&nbsp;&lt;=&nbsp;<span style="color:#a31515;">&#39;Z&#39;</span>)
 
<span style="color:blue;">type</span>&nbsp;<span style="color:#2b91af;">DiamondPropertyAttribute</span>()&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">inherit</span>&nbsp;<span style="color:#2b91af;">PropertyAttribute</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arbitrary&nbsp;=&nbsp;[|&nbsp;typeof&lt;<span style="color:#2b91af;">Letters</span>&gt;&nbsp;|],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)
 
[&lt;<span style="color:#2b91af;">DiamondProperty</span>&gt;]
<span style="color:blue;">let</span>&nbsp;``Diamond&nbsp;is&nbsp;non-empty``&nbsp;(letter&nbsp;:&nbsp;<span style="color:#2b91af;">char</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#2b91af;">Diamond</span>.make&nbsp;letter
&nbsp;&nbsp;&nbsp;&nbsp;not&nbsp;(<span style="color:#2b91af;">String</span>.IsNullOrWhiteSpace&nbsp;actual)</pre>    
  </p>
  <p>
    The Letters type redefines how char values are generated, using the default generator of char, but then filtering the values so that they only fall in the range [A-Z].
  </p>
  <p>
    To save myself from a bit of typing, I also defined the custom DiamondPropertyAttribute that uses the Letters type, and used it to adorn the test function instead of FsCheck's built-in PropertyAttribute.
  </p>
  <h3 id="367c2ba1ac02450b84ca1d2d2408819d">
    Top and bottom <a href="#367c2ba1ac02450b84ca1d2d2408819d" title="permalink">#</a>
  </h3>
  <p>
    Considering the TPP, I wondered which property I should write next, since I wanted to define a property that would force me to change my current implementation in the right direction, but only by a small step.
  </p>
  <p>
    A good candidate seemed to state something about the top and bottom of the diamond: the first and the last line of the diamond must always contain a single 'A'. Here's how I expressed that in code:
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;split&nbsp;(x&nbsp;:&nbsp;<span style="color:#2b91af;">string</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;x.Split([|&nbsp;<span style="color:#2b91af;">Environment</span>.NewLine&nbsp;|],&nbsp;<span style="color:#2b91af;">StringSplitOptions</span>.None)
 
<span style="color:blue;">let</span>&nbsp;trim&nbsp;(x&nbsp;:&nbsp;<span style="color:#2b91af;">string</span>)&nbsp;=&nbsp;x.Trim()
 
[&lt;<span style="color:#2b91af;">DiamondProperty</span>&gt;]
<span style="color:blue;">let</span>&nbsp;``First&nbsp;row&nbsp;contains&nbsp;A``&nbsp;(letter&nbsp;:&nbsp;<span style="color:#2b91af;">char</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#2b91af;">Diamond</span>.make&nbsp;letter
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;rows&nbsp;=&nbsp;split&nbsp;actual
&nbsp;&nbsp;&nbsp;&nbsp;rows&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.head&nbsp;|&gt;&nbsp;trim&nbsp;=&nbsp;<span style="color:#a31515;">&quot;A&quot;</span>
 
[&lt;<span style="color:#2b91af;">DiamondProperty</span>&gt;]
<span style="color:blue;">let</span>&nbsp;``Last&nbsp;row&nbsp;contains&nbsp;A``&nbsp;(letter&nbsp;:&nbsp;<span style="color:#2b91af;">char</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#2b91af;">Diamond</span>.make&nbsp;letter
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;rows&nbsp;=&nbsp;split&nbsp;actual
&nbsp;&nbsp;&nbsp;&nbsp;rows&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.last&nbsp;|&gt;&nbsp;trim&nbsp;=&nbsp;<span style="color:#a31515;">&quot;A&quot;</span></pre>
  </p>
  <p>
    Notice that I wrote the test-specific helper functions <code>split</code> and <code>trim</code> in order to make the code a bit more readable, and that I also decided to define the property for the top of the diamond separately from the property for the bottom.
  </p>
  <p>
    In the degenerate case where the input is 'A', the first and the last rows are identical, but the properties still hold.
  </p>
  <p>
    Using the Devil's Advocate, this implementation passes all properties defined so far:
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;make&nbsp;letter&nbsp;=&nbsp;<span style="color:#a31515;">&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;</span>
</pre>
  </p>
  <p>
    This is slightly better, but I purposely placed the 'A' slightly off-centre. In fact, the entire hard-coded string is 16 characters wide, so it can never have a single, centred letter. The next property should address this problem.
  </p>
  <h3 id="2acffba1f9f246a1a722025d1592a89e">
    Vertical symmetry <a href="#2acffba1f9f246a1a722025d1592a89e" title="permalink">#</a>
  </h3>
  <p>
    A fairly important property of the diamond is that it must be symmetric. Here's how I defined symmetry over the vertical axis:
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;leadingSpaces&nbsp;(x&nbsp;:&nbsp;<span style="color:#2b91af;">string</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;indexOfNonSpace&nbsp;=&nbsp;x.IndexOfAny&nbsp;[|&nbsp;<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;..&nbsp;<span style="color:#a31515;">&#39;Z&#39;</span>&nbsp;|]
&nbsp;&nbsp;&nbsp;&nbsp;x.Substring(0,&nbsp;indexOfNonSpace)
 
<span style="color:blue;">let</span>&nbsp;trailingSpaces&nbsp;(x&nbsp;:&nbsp;<span style="color:#2b91af;">string</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;lastIndexOfNonSpace&nbsp;=&nbsp;x.LastIndexOfAny&nbsp;[|&nbsp;<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;..&nbsp;<span style="color:#a31515;">&#39;Z&#39;</span>&nbsp;|]
&nbsp;&nbsp;&nbsp;&nbsp;x.Substring(lastIndexOfNonSpace&nbsp;+&nbsp;1)
 
[&lt;<span style="color:#2b91af;">DiamondProperty</span>&gt;]
<span style="color:blue;">let</span>&nbsp;``All&nbsp;rows&nbsp;must&nbsp;have&nbsp;a&nbsp;symmetric&nbsp;contour``&nbsp;(letter&nbsp;:&nbsp;<span style="color:#2b91af;">char</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#2b91af;">Diamond</span>.make&nbsp;letter
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;rows&nbsp;=&nbsp;split&nbsp;actual
&nbsp;&nbsp;&nbsp;&nbsp;rows&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Array</span>.forall&nbsp;(<span style="color:blue;">fun</span>&nbsp;r&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;(leadingSpaces&nbsp;r)&nbsp;=&nbsp;(trailingSpaces&nbsp;r))
</pre>
  </p>
  <p>
    Using the two new helper functions, this property states that the diamond should have a symmetric contour; that is, that it's <em>external</em> shape should be symmetric. The property doesn't define what's inside of the diamond.
  </p>
  <p>
    Again, using the Devil's Advocate technique, this implementations passes all tests:
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;make&nbsp;letter&nbsp;=&nbsp;<span style="color:#a31515;">&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;</span>
</pre>
  </p>
  <p>
    At least the string is now symmetric, but it feels like we aren't getting anywhere, so it's time to define a property that will force me to <em>use</em> the input letter.
  </p>
  <h3 id="77c8f03bb3c748f89e401cd1895f488a">
    Letters, in correct order <a href="#77c8f03bb3c748f89e401cd1895f488a" title="permalink">#</a>
  </h3>
  <p>
    When considering the shape of the required diamond, we know that the first line should contain an 'A', the next line should contain a 'B', the third line a 'C', and so on, until the input letter is reached, after which the order is reversed. Here's my way of stating that:
  </p>
  <p>
    <pre>[&lt;<span style="color:#2b91af;">DiamondProperty</span>&gt;]
<span style="color:blue;">let</span>&nbsp;``Rows&nbsp;must&nbsp;contain&nbsp;the&nbsp;correct&nbsp;letters,&nbsp;in&nbsp;the&nbsp;correct&nbsp;order``
&nbsp;&nbsp;&nbsp;&nbsp;(letter&nbsp;:&nbsp;<span style="color:#2b91af;">char</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#2b91af;">Diamond</span>.make&nbsp;letter
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;letters&nbsp;=&nbsp;[<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;..&nbsp;letter]
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;expectedLetters&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letters&nbsp;@&nbsp;(letters&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.rev&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.tail)&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.toArray
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;rows&nbsp;=&nbsp;split&nbsp;actual
&nbsp;&nbsp;&nbsp;&nbsp;expectedLetters&nbsp;=&nbsp;(rows&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Array</span>.map&nbsp;trim&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Array</span>.map&nbsp;<span style="color:#2b91af;">Seq</span>.head)</pre>
  </p>
  <p>
    The expression <code>let</span>&nbsp;letters&nbsp;=&nbsp;[<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;..&nbsp;letter]</code> produces a list of letters up to, and including, the input letter. As an example, if <code>letter</code> is 'D', then <code>letters</code> will be <code>['A';&nbsp;'B';&nbsp;'C';&nbsp;'D']</code>. That's only the top and middle parts of the diamond, but we can use <code>letters</code> again: we just have to reverse it (<code>['D';&nbsp;'C';&nbsp;'B';&nbsp;'A']</code>) and throw away the first element ('D') in order to remove the duplicate in the middle.
  </p>
  <p>
    This property is still quite loosely stated, because it only states that each row's first non-white space character should be the expected letter, but it doesn't say anything about subsequent letters. The reason I defined this property so loosely was that I didn't want to force too many changes on the implementation at once. The simplest implementation I could think of was this:
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;make&nbsp;letter&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;letters&nbsp;=&nbsp;[<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;..&nbsp;letter]
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;letters&nbsp;=&nbsp;letters&nbsp;@&nbsp;(letters&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.rev&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.tail)
&nbsp;&nbsp;&nbsp;&nbsp;letters
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.map&nbsp;string&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.reduce&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;y&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%s%s</span><span style="color:#a31515;">&quot;</span>&nbsp;x&nbsp;System.<span style="color:#2b91af;">Environment</span>.NewLine&nbsp;y)</pre>
  </p>
  <p>
    It duplicates the test code a bit, because it reuse the algorithm that generates the desired sequence of letters. However, <a href="/2014/08/07/why-dry">I'm not too concerned about the occasional DRY violation</a>.
  </p>
  <p>
    For the input 'D', this implementation produces this output:
  </p>
  <p>
    <pre>A
B
C
D
C
B
A</pre>
  </p>
  <p>
    All properties still hold. Obviously this isn't correct yet, but I was happy that I was able to define a property that led me down a path where I could take a small, controlled step towards a more correct solution.
  </p>
  <h3 id="0f1b3aaf4f1b4b49b01622c15c7ad00e">
    As wide as it's high <a href="#0f1b3aaf4f1b4b49b01622c15c7ad00e" title="permalink">#</a>
  </h3>
  <p>
    While I already have various properties that examine the white space around the letters, I've now temporarily arrived at an implementation entirely without white space. This made me consider how I could take advantage of those, and combine them with a new property, to re-introduce the second dimension to the figure.
  </p>
  <p>
    It's fairly clear that the figure must be as wide as it's high, if we count both width and height in number of letters. This property is easy to define:
  </p>
  <p>
    <pre>[&lt;DiamondProperty&gt;]
<span style="color:blue;">let</span>&nbsp;``Diamond&nbsp;is&nbsp;as&nbsp;wide&nbsp;as&nbsp;it&#39;s&nbsp;high``&nbsp;(letter&nbsp;:&nbsp;char)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;Diamond.make&nbsp;letter
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;rows&nbsp;=&nbsp;split&nbsp;actual
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;expected&nbsp;=&nbsp;rows.Length
&nbsp;&nbsp;&nbsp;&nbsp;rows&nbsp;|&gt;&nbsp;Array.forall&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x.Length&nbsp;=&nbsp;expected)</pre>
  </p>
  <p>
    It simply verifies that each row has exactly the same number of letters as there are rows in the figure. My implementation then became this:
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;make&nbsp;letter&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;makeLine&nbsp;width&nbsp;letter&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">match</span>&nbsp;letter&nbsp;<span style="color:blue;">with</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;padding&nbsp;=&nbsp;String(<span style="color:#a31515;">&#39;&nbsp;&#39;</span>,&nbsp;(width&nbsp;-&nbsp;1)&nbsp;/&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%c%s</span><span style="color:#a31515;">&quot;</span>&nbsp;padding&nbsp;letter&nbsp;padding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;String(letter,&nbsp;width)
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;letters&nbsp;=&nbsp;[<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;..&nbsp;letter]
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;letters&nbsp;=&nbsp;letters&nbsp;@&nbsp;(letters&nbsp;|&gt;&nbsp;List.rev&nbsp;|&gt;&nbsp;List.tail)
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;width&nbsp;=&nbsp;letters.Length
 
&nbsp;&nbsp;&nbsp;&nbsp;letters
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;List.map&nbsp;(makeLine&nbsp;width)
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;List.reduce&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;y&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%s%s</span><span style="color:#a31515;">&quot;</span>&nbsp;x&nbsp;Environment.NewLine&nbsp;y)</pre>
  </p>
  <p>
    This prompted me to introduce a private makeLine function, which produces the line for a single letter. It has a special case to handle the 'A', since this value is the only value where there's only a single letter on a line. For all other letters, there will be two letters - eventually with spaces between them.
  </p>
  <p>
    This seemed a reasonable rationale for introducing a branch in the code, but after having completed the kata, I can see that <a href="http://natpryce.com/articles/000807.html">Nat Pryce has a more elegant solution</a>.
  </p>
  <p>
    If the input is 'D' the output now looks like this:
  </p>
  <p>
    <pre>   A   
BBBBBBB
CCCCCCC
DDDDDDD
CCCCCCC
BBBBBBB
   A   </pre>
  </p>
  <p>
    There's still not much white space in the implementation, but at least we regained the second dimension of the figure.
  </p>
  <h3 id="3f6cc532b1a14515842adf9742bed959">
    Inner space <a href="#3f6cc532b1a14515842adf9742bed959" title="permalink">#</a>
  </h3>
  <p>
    The next incremental change I wanted to introduce was the space between two letters. It seemed reasonable that this would be a small step for the makeLine function.
  </p>
  <p>
    <pre>[&lt;<span style="color:#2b91af;">DiamondProperty</span>&gt;]
<span style="color:blue;">let</span>&nbsp;``All&nbsp;rows&nbsp;except&nbsp;top&nbsp;and&nbsp;bottom&nbsp;have&nbsp;two&nbsp;identical&nbsp;letters``
&nbsp;&nbsp;&nbsp;&nbsp;(letter&nbsp;:&nbsp;<span style="color:#2b91af;">char</span>)&nbsp;=
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#2b91af;">Diamond</span>.make&nbsp;letter
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;isTwoIdenticalLetters&nbsp;x&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;hasIdenticalLetters&nbsp;=&nbsp;x&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.distinct&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.length&nbsp;=&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;hasTwoLetters&nbsp;=&nbsp;x&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.length&nbsp;=&nbsp;2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasIdenticalLetters&nbsp;&amp;&amp;&nbsp;hasTwoLetters
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;rows&nbsp;=&nbsp;split&nbsp;actual
&nbsp;&nbsp;&nbsp;&nbsp;rows
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Array</span>.filter&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;not&nbsp;(x.Contains(<span style="color:#a31515;">&quot;A&quot;</span>)))
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Array</span>.map&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x.Replace(<span style="color:#a31515;">&quot;&nbsp;&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;&quot;</span>))
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Array</span>.forall&nbsp;isTwoIdenticalLetters</pre>
  </p>
  <p>
    The property itself simply states that each row must consist of exactly two identical letters, and then white space to fill out the shape. The way to verify this is to first replace all spaces with the empty string, and then examine the remaining string. Each remaining string must contain exactly two letters, so its length must be 2, and if you perform a <code>distinct</code> operation on its constituent char values, the resulting sequence of chars should have a length of 1.
  </p>
  <p>
    This property only applies to the 'internal' rows, but not the top and bottom rows that contain a single 'A', so these rows are filtered out.
  </p>
  <p>
    The new property itself only states that apart from the 'A' rows, each row must have exactly two identical letters. Because the tests for the 'A' rows, together with the tests for symmetric contours, already imply that each row must have a width of an uneven number, and again because of the symmetric contour requirement, I had to introduce <em>at least</em> a single space between the two characters.
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;make&nbsp;letter&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;makeLine&nbsp;width&nbsp;letter&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">match</span>&nbsp;letter&nbsp;<span style="color:blue;">with</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;padding&nbsp;=&nbsp;<span style="color:#2b91af;">String</span>(<span style="color:#a31515;">&#39;&nbsp;&#39;</span>,&nbsp;(width&nbsp;-&nbsp;1)&nbsp;/&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%c%s</span><span style="color:#a31515;">&quot;</span>&nbsp;padding&nbsp;letter&nbsp;padding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;innerSpace&nbsp;=&nbsp;<span style="color:#2b91af;">String</span>(<span style="color:#a31515;">&#39;&nbsp;&#39;</span>,&nbsp;width&nbsp;-&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%c%s%c</span><span style="color:#a31515;">&quot;</span>&nbsp;letter&nbsp;innerSpace&nbsp;letter
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;letters&nbsp;=&nbsp;[<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;..&nbsp;letter]
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;letters&nbsp;=&nbsp;letters&nbsp;@&nbsp;(letters&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.rev&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.tail)
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;width&nbsp;=&nbsp;letters.Length
 
&nbsp;&nbsp;&nbsp;&nbsp;letters
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.map&nbsp;(makeLine&nbsp;width)
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.reduce&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;y&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%s%s</span><span style="color:#a31515;">&quot;</span>&nbsp;x&nbsp;<span style="color:#2b91af;">Environment</span>.NewLine&nbsp;y)</pre>
  </p>
  <p>
    Using the Devil's Advocate technique, it seems that the simplest way of passing all tests is to fill out the inner space completely. Here's an example of calling Diamond.make 'D' with the current implementation:
  </p>
  <p>
    <pre>   A   
B     B
C     C
D     D
C     C
B     B
   A   </pre>
  </p>
  <p>
    Again, I like how this new property enabled me to do an incremental change to the implementation. Visually, we can see that the figure looks 'more correct' than it previously did.
  </p>
  <h3 id="a12dfe230d3443e3bc611beb5b6224f0">
    Bottom triangle <a href="#a12dfe230d3443e3bc611beb5b6224f0" title="permalink">#</a>
  </h3>
  <p>
    At this point I thought that it was appropriate to begin to address the diamond shape of the figure. After having spent some time considering how to express that without repeating the implementation code, I decided that the easiest step would be to verify that the lower left space forms a triangle.
  </p>
  <p>
    <pre>[&lt;<span style="color:#2b91af;">DiamondProperty</span>&gt;]
<span style="color:blue;">let</span>&nbsp;``Lower&nbsp;left&nbsp;space&nbsp;is&nbsp;a&nbsp;triangle``&nbsp;(letter&nbsp;:&nbsp;<span style="color:#2b91af;">char</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#2b91af;">Diamond</span>.make&nbsp;letter
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;rows&nbsp;=&nbsp;split&nbsp;actual
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;lowerLeftSpace&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rows
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.skipWhile&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;not&nbsp;(x.Contains(string&nbsp;letter)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.map&nbsp;leadingSpaces
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;spaceCounts&nbsp;=&nbsp;lowerLeftSpace&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.map&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x.Length)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;expected&nbsp;=&nbsp;<span style="color:#2b91af;">Seq</span>.initInfinite&nbsp;id
&nbsp;&nbsp;&nbsp;&nbsp;spaceCounts
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.zip&nbsp;expected
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.forall&nbsp;(<span style="color:blue;">fun</span>&nbsp;(x,&nbsp;y)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;x&nbsp;=&nbsp;y)</pre>
  </p>
  <p>
    This one is a bit tricky. It examines the shape of the lower left white space. Getting that shape itself is easy enough, using the previously defined leadingSpaces helper function. For each row, <code>spaceCounts</code> contains the number of leading spaces.
  </p>
  <p>
    The <code>expected</code> value contains an infinite sequence of numbers, {0; 1; 2; 3; 4; ...} because, due to the random nature of Property-Based Testing, I don't know exactly how many numbers to expect.
  </p>
  <p>
    Zipping an infinite sequence with a finite sequence matches elements in each sequence, until the shortest sequence (that would be the finite sequence) ends. Each resulting element is a tuple, and if the lower left space forms a triangle, the sequence of tuples should look like this: {(0, 0); (1, 1); (2, 2); ...}. The final step in the property is therefore to verify that all of those tuples have identical elements.
  </p>
  <p>
    The implementation uses Devil's Advocate, and goes quite a bit out of its way to make the top of the figure wrong. As you'll see shortly, it will actually be a simpler implementation to keep the figure symmetric around the horizontal axis as well, but we should have that as an explicit property.
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;make&nbsp;letter&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;makeLine&nbsp;width&nbsp;(letter,&nbsp;letterIndex)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">match</span>&nbsp;letter&nbsp;<span style="color:blue;">with</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;padding&nbsp;=&nbsp;<span style="color:#2b91af;">String</span>(<span style="color:#a31515;">&#39;&nbsp;&#39;</span>,&nbsp;(width&nbsp;-&nbsp;1)&nbsp;/&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%c%s</span><span style="color:#a31515;">&quot;</span>&nbsp;padding&nbsp;letter&nbsp;padding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;innerSpaceWidth&nbsp;=&nbsp;letterIndex&nbsp;*&nbsp;2&nbsp;-&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;padding&nbsp;=&nbsp;<span style="color:#2b91af;">String</span>(<span style="color:#a31515;">&#39;&nbsp;&#39;</span>,&nbsp;(width&nbsp;-&nbsp;2&nbsp;-&nbsp;innerSpaceWidth)&nbsp;/&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;innerSpace&nbsp;=&nbsp;<span style="color:#2b91af;">String</span>(<span style="color:#a31515;">&#39;&nbsp;&#39;</span>,&nbsp;innerSpaceWidth)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%c%s%c%s</span><span style="color:#a31515;">&quot;</span>&nbsp;padding&nbsp;letter&nbsp;innerSpace&nbsp;letter&nbsp;padding
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;indexedLetters&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;..&nbsp;letter]&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.mapi&nbsp;(<span style="color:blue;">fun</span>&nbsp;i&nbsp;l&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;l,&nbsp;i)&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.toList
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;indexedLetters&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;indexedLetters
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.map&nbsp;(<span style="color:blue;">fun</span>&nbsp;(l,&nbsp;_)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;l,&nbsp;1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.rev
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.tail
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.rev)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@&nbsp;(indexedLetters&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.rev)
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;width&nbsp;=&nbsp;indexedLetters.Length
 
&nbsp;&nbsp;&nbsp;&nbsp;indexedLetters
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.map&nbsp;(makeLine&nbsp;width)
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.reduce&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;y&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%s%s</span><span style="color:#a31515;">&quot;</span>&nbsp;x&nbsp;<span style="color:#2b91af;">Environment</span>.NewLine&nbsp;y)</pre>
  </p>
  <p>
    The main change here is that now each letter is being indexed, but then I deliberately throw away the indexes for the top part, in order to force myself to add yet another property later. While I could have skipped this step, and gone straight for the correct solution at this point, I was, after all, doing a kata, so I also wanted to write one last property.
  </p>
  <p>
    The current implementation produces the figure below when Diamond.make is called with 'D':
  </p>
  <p>
    <pre>   A   
  B B  
  C C  
D     D
 C   C 
  B B  
   A   </pre>
  </p>
  <p>
    The shape is almost there, but obviously, the top is wrong, because I deliberately made it so.
  </p>
  <h3 id="e5ca655a760d4380bf061851ee733471">
    Horizontal symmetry <a href="#e5ca655a760d4380bf061851ee733471" title="permalink">#</a>
  </h3>
  <p>
    Just as the figure must be symmetric over its vertical axis, it must also be symmetric over its horizontal axis:
  </p>
  <p>
    <pre>[&lt;<span style="color:#2b91af;">DiamondProperty</span>&gt;]
<span style="color:blue;">let</span>&nbsp;``Figure&nbsp;is&nbsp;symmetric&nbsp;around&nbsp;the&nbsp;horizontal&nbsp;axis``&nbsp;(letter&nbsp;:&nbsp;<span style="color:#2b91af;">char</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#2b91af;">Diamond</span>.make&nbsp;letter
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;rows&nbsp;=&nbsp;split&nbsp;actual
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;topRows&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rows
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.takeWhile&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;not&nbsp;(x.Contains(string&nbsp;letter)))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.toList
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;bottomRows&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rows
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.skipWhile&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;not&nbsp;(x.Contains(string&nbsp;letter)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.skip&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.toList
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.rev
&nbsp;&nbsp;&nbsp;&nbsp;topRows&nbsp;=&nbsp;bottomRows</pre>
  </p>
  <p>
    This property finally 'allows' me to simplify my implementation:
  </p>
  <p>
    <pre><span style="color:blue;">let</span>&nbsp;make&nbsp;letter&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;makeLine&nbsp;width&nbsp;(letter,&nbsp;letterIndex)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">match</span>&nbsp;letter&nbsp;<span style="color:blue;">with</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;padding&nbsp;=&nbsp;<span style="color:#2b91af;">String</span>(<span style="color:#a31515;">&#39;&nbsp;&#39;</span>,&nbsp;(width&nbsp;-&nbsp;1)&nbsp;/&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%c%s</span><span style="color:#a31515;">&quot;</span>&nbsp;padding&nbsp;letter&nbsp;padding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;innerSpaceWidth&nbsp;=&nbsp;letterIndex&nbsp;*&nbsp;2&nbsp;-&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;padding&nbsp;=&nbsp;<span style="color:#2b91af;">String</span>(<span style="color:#a31515;">&#39;&nbsp;&#39;</span>,&nbsp;(width&nbsp;-&nbsp;2&nbsp;-&nbsp;innerSpaceWidth)&nbsp;/&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;innerSpace&nbsp;=&nbsp;<span style="color:#2b91af;">String</span>(<span style="color:#a31515;">&#39;&nbsp;&#39;</span>,&nbsp;innerSpaceWidth)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%c%s%c%s</span><span style="color:#a31515;">&quot;</span>&nbsp;padding&nbsp;letter&nbsp;innerSpace&nbsp;letter&nbsp;padding
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;indexedLetters&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#a31515;">&#39;A&#39;</span>&nbsp;..&nbsp;letter]&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.mapi&nbsp;(<span style="color:blue;">fun</span>&nbsp;i&nbsp;l&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;l,&nbsp;i)&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">Seq</span>.toList
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;indexedLetters&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexedLetters&nbsp;@&nbsp;(indexedLetters&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.rev&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.tail)
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;width&nbsp;=&nbsp;indexedLetters.Length
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;indexedLetters
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.map&nbsp;(makeLine&nbsp;width)
&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#2b91af;">List</span>.reduce&nbsp;(<span style="color:blue;">fun</span>&nbsp;x&nbsp;y&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;sprintf&nbsp;<span style="color:#a31515;">&quot;</span><span style="color:#2b91af;">%s%s%s</span><span style="color:#a31515;">&quot;</span>&nbsp;x&nbsp;<span style="color:#2b91af;">Environment</span>.NewLine&nbsp;y)</pre>
  </p>
  <p>
    Calling Diamond.make with 'D' now produces:
  </p>
  <p>
    <pre>   A
  B B
 C   C
D     D
 C   C 
  B B  
   A   </pre>
  </p>
  <p>
    It works with other letters, too.
  </p>
  <h3 id="c525f4e19c544e679cf63d6e4f650fcf">
    Summary <a href="#c525f4e19c544e679cf63d6e4f650fcf" title="permalink">#</a>
  </h3>
  <p>
    It turned out to be an interesting exercise to do this kata with Property-Based Testing. To me, the most surprising part was that it was much easier to approach the problem in an incremental fashion than it was with Example-Driven Development.
  </p>
  <p>
    If you're interested in perusing the source code, including my detailed, step-by-step commit remarks, it's <a href="https://github.com/ploeh/DiamondFsCheck">on GitHub</a>. If you want to learn more about Property-Based Testing, you can watch my <a href="{{ site.production_url }}/property-based-testing-intro">Introduction to Property-based Testing with F#</a> Pluralsight course. There are more examples in some of my other F# Pluralsight courses - particularly <a href="{{ site.production_url }}/type-driven-development-with-fsharp">Type-Driven Development with F#</a>.
  </p>
</div>