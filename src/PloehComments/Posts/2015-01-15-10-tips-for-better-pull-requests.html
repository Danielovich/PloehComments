---
layout: post
title: "10 tips for better Pull Requests"
description: "Making a good Pull Request involves more than writing good code."
date: 2015-01-15 10:06 UTC
tags: [Productivity]
---
{% include JB/setup %}

<div id="post">
  <p>
    <em>{{ page.description }}</em>
  </p>
  <p>
    The Pull Request model has turned out to be a great way to build software in teams - particularly for distributed teams; not only for open source development, but also in enterprises. Since some time around 2010, I've been reviewing Pull Requests both for my open source projects, but also as a team member for some of my customers, doing closed-source software, but still using the Pull Request work flow internally.
  </p>
  <p>
    During all of that time, I've seen many great Pull Requests, and some that needed some work.
  </p>
  <p>
    A good Pull Request involves more than just some code. In most cases, there's one or more reviewer(s) involved, who will have to review your Pull Request in order to evaluate whether it's a good fit for inclusion in the code base. Not only must you produce good code, but you must also cater to the person(s) doing the review.
  </p>
  <p>
    Here's a list of tips to make your Pull Request better. It isn't exhaustive, but I think it addresses some of the more important aspects of creating a good Pull Request.
  </p>
  <h3 id="e54d3e63e198471bb34b92606326d0e3">
    1. Make it small <a href="#e54d3e63e198471bb34b92606326d0e3" title="permalink">#</a>
  </h3>
  <p>
    A small, focused Pull Request gives you the best chance of having it accepted.
  </p>
  <p>
    The first thing I do when I get a notification about a Pull Request is that I look it over to get an idea about its size. It takes time to properly review a Pull Request, and in my experience, the time it takes is exponential to the size; the relationship certainly isn't linear.
  </p>
  <p>
    If I get a big Pull Request for an open source project, I do realize that the submitter has most likely already put in substantial work in his or her spare time, so I do go to some lengths to review a big Pull Request, even if I think it's too big - particularly when it looks like it's a first-time contributor. Still, if the Pull Request is big, I'll need to <em>schedule</em> time to review it: I can't review a big chunk of code using five minutes here and five minutes there; I need contiguous time to do that. This already introduces a delay into the review process.
  </p>
  <p>
    If I get a big Pull Request in a professional setting (i.e. where the submitter is being paid to write the code), I often reject the Pull Request simply because of the size of it.
  </p>
  <p>
    How small is small enough? Obviously, it depends on what the Pull Request is about, but a Pull Request that touches less than a dozen files isn't too bad.
  </p>
  <h3 id="9456245213574e5b879092ad3f658fc0">
    2. Do only one thing <a href="#9456245213574e5b879092ad3f658fc0" title="permalink">#</a>
  </h3>
  <p>
    Just as the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a> states that a class should have only one responsibility, so should a Pull Request address only a single concern.
  </p>
  <p>
    Imagine, as a counter-example, that you submit a Pull Request that addresses three independent, separate concerns (let's call them A, B, and C). The reviewer may immediately agree with you that A and C are valid concerns, and that your solution is correct. However, the reviewer has issues with your B concern. Perhaps he or she thinks it's not a concern at all, or she disagrees with the way you've addressed it.
  </p>
  <p>
    This becomes the start of a lengthy discussion about concern B, and how it's being addressed. This discussion can go on for days (particularly if you're in different time zones), while you attempt to come to agreement; perhaps you'll need to make changes to your Pull Request to address the reviewer's concerns. This all takes time.
  </p>
  <p>
    It may, in fact, take so much time that other commits have been merged into <em>master</em> in the meantime, and your Pull Request has fallen so much behind that it no longer can be automatically merged. Welcome to Merge Hell.
  </p>
  <p>
    All that time, your perfectly acceptable solutions to the A and C concerns are sitting idly in your Pull Request, adding absolutely no value to the overall code base.
  </p>
  <p>
    Instead, submit three independent Pull Requests that address respectively A, B, and C. If you do that, the reviewer who agrees with A and C will immediately accept two of those three Pull Requests. In this way, your non-controversial contributions can immediately add value to the code base.
  </p>
  <p>
    The more concerns you address in a single Pull Request, the bigger the risk that at least one of them will block acceptance of your contribution. Do only one thing per Pull Request. It also helps you make each Pull Request smaller.
  </p>
  <h3 id="dc285209d34e43f2bfe6061c7d6b8597">
    3. Watch your line width <a href="#dc285209d34e43f2bfe6061c7d6b8597" title="permalink">#</a>
  </h3>
  <p>
    The reviewer of your Pull Request will most likely be reviewing your contribution using a diff tool. Both <a href="https://github.com">GitHub</a> and <a href="https://www.atlassian.com/software/stash">Stash</a> provide browser-based diff views for reviewing. A reviewer can even configure the diff view to be side-by-side; it makes it much easier to understand what changes are included in the contribution, but it also means that the code must be readable on half a screen.
  </p>
  <p>
    If you have wide lines, you force the reviewer to scroll horizontally.
  </p>
  <p>
    There are <a href="http://richarddingwall.name/2008/05/31/is-the-80-character-line-limit-still-relevant">many reasons to keep line width below 80 characters</a>; making your code easy to review just adds another reason to that list.
  </p>
  <h3 id="856ba43cbf9148a384bea7e15f2ca563">
    4. Avoid re-formatting <a href="#856ba43cbf9148a384bea7e15f2ca563" title="permalink">#</a>
  </h3>
  <p>
    You may feel the urge to change the formatting of the existing code to fit 'your' style. Please abstain.
  </p>
  <p>
    Every byte you change in the source code shows up in the diff views. Some diff viewers have options to ignore changes of white space, but even with this option on, there are limits to what those diff viewers can ignore. Particularly, they can't ignore if you move code around, so please don't do that.
  </p>
  <p>
    If you really need to address white space issues, move code around within files, change formatting, or do other stylistic changes to the code, please do so in an isolated pull request that does only that, and state so in your Pull Request comment.
  </p>
  <h3 id="b48faf1499cf4038b9bf2abead031f5e">
    5. Make sure the code builds <a href="#b48faf1499cf4038b9bf2abead031f5e" title="permalink">#</a>
  </h3>
  <p>
    Before submitting a Pull Request, build it on your own machine. True, <em>works on my machine</em> isn't particularly useful, but it's a minimum bar. If it <em>doesn't work on your machine</em>, it's unlikely to work on other machines as well.
  </p>
  <p>
    Watch out for compiler warnings. They may not prevent you from compiling, so you may not notice them if you don't explicitly look for them. However, if your Pull Request causes (more) compiler warnings, a reviewer may reject it; I do.
  </p>
  <p>
    If the project has a build script, try to run that, and only submit your pull request if the build succeeds. In many of my open source projects, I have a build script that (among other things) treats warnings as errors. Such a build script may automate or implement various rules for that particular code base. Use it before submitting, because the reviewer most likely will use it before merging your branch.
  </p>
  <h3 id="5efded28438149de80acde5ebd2ca87f">
    6. Make sure all tests pass <a href="#5efded28438149de80acde5ebd2ca87f" title="permalink">#</a>
  </h3>
  <p>
    Assuming that the code base in question has automated tests, make sure all tests pass before submitting a Pull Request.
  </p>
  <p>
    This should go without saying, but I regularly receive Pull Requests where one or more tests are failing.
  </p>
  <h3 id="fcd3da7df1294380b0b50b092ae098a9">
    7. Add tests <a href="#fcd3da7df1294380b0b50b092ae098a9" title="permalink">#</a>
  </h3>
  <p>
    Again, assuming that the code in question already has automated (unit) tests, do add tests for the code you submit.
  </p>
  <p>
    It doesn't often happen that I receive a Pull Request without tests, but when I do, I often reject it.
  </p>
  <p>
    This isn't a hard rule. There are various cases where you may need to add code without test coverage (e.g. when adding a <a href="http://xunitpatterns.com/Humble%20Object.html">Humble Object</a>), but if it can be tested, it should be tested.
  </p>
  <p>
    You'll need to follow the testing strategy already established for the code base in question.
  </p>
  <h3 id="698cd08fcaa04ef0bed29be8a2e2634d">
    8. Document your reasoning <a href="#698cd08fcaa04ef0bed29be8a2e2634d" title="permalink">#</a>
  </h3>
  <p>
    Self-documenting code rarely is.
  </p>
  <p>
    Yes, <a href="http://butunclebob.com/ArticleS.TimOttinger.ApologizeIncode">code comments are apologies</a>, and I definitely prefer well-named operations, types, and values over comments. Still, when writing code, you often have to make decisions that aren't self-evident (particularly when dealing with Business 'Logic').
  </p>
  <p>
    Document <em>why</em> you wrote the code in the way you did; not what it does.
  </p>
  <p>
    My preferred priority is this:
    <ol>
      <li>
        <strong>Self-documenting code:</strong> You <em>can</em> make some decisions about the code self-documenting. <a href="http://amzn.to/XCJi9X">Clean Code</a> is literally a book on how to do that.
      </li>
      <li>
        <strong>Code comments:</strong> If you can't make the code sufficiently self-documenting, add a code comment. At least, the comment is co-located with the code, so even in the unlikely event that you decide to change version control system, the comment is still preserved. <a href="https://github.com/GreanTech/AtomEventStore/blob/e5fe679c08abb6fe108509117651d29dce17e270/AtomEventStore/AtomEventStorage.cs#L68-L71">Here's an example where I found a comment more appropriate than attempting to design my way out of the problem.</a>
      </li>
      <li>
        <strong>Commit messages:</strong> Most version control systems give you the opportunity to write a commit message. Most people don't bother putting anything other than a bare minimum into these, but you can document your reasoning here as well. Sometimes, you'll need to explain why you're doing things in a certain order. This doesn't fit well in code comments, but is a good fit for a commit message. As long as you keep using the same version control system, you preserve these commit messages, but they're once removed from the actual source code, and you may loose the messages if you change to another source control system. <a href="https://github.com/GreanTech/AtomEventStore/commit/615cdee2c4d675d412e6669bcc0678655376c4d1">Here's an example where I felt the need to write an extensive commit message</a>, but <a href="https://github.com/GreanTech/AtomEventStore/commit/e5fe679c08abb6fe108509117651d29dce17e270">I don't always do that</a>.
      </li>
      <li>
        <strong>Pull Request comments:</strong> Rarely, you may find yourself in a situation where none of the above options are appropriate. In Pull Request management systems such as GitHub or Stash, you can also add custom messages to the Pull Request itself. This message is twice removed from the actual source code, and will only persist as long as you keep using the same host. If you move from e.g. CodePlex to GitHub, you'll loose those Pull Request messages. Still, occasionally, I find that I need to explain myself to the reviewer, but the explanation involves something external to the source code anyway. <a href="https://github.com/GreanTech/AtomEventStore/pull/70">Here's an example where I found that a reasonable approach.</a>
      </li>
    </ol>
    You don't need to explain the obvious, but do consider erring on the side of caution. What's obvious to you today may not be obvious to anyone else, or to you in three months.
  </p>
  <h3 id="e5bfc9498c704d31b45bd111599764bd">
    9. Write well <a href="#e5bfc9498c704d31b45bd111599764bd" title="permalink">#</a>
  </h3>
  <p>
    Write good code, but also write good prose. This is partly subjective, but there are rules for both code and prose. Code has correctness rules: if you break them, it doesn't compile (or, for interpreted languages, it fails at run-time).
  </p>
  <p>
    The same goes for the prose you may add: Code comments. Commit messages. Pull Request messages.
  </p>
  <p>
    Please use correct spelling, grammar, and punctuation. If you don't, your prose is harder to understand, and your reviewer is a human being.
  </p>
  <h3 id="ee2c4948822641c5b31d5c6918550d15">
    10. Avoid thrashing <a href="#ee2c4948822641c5b31d5c6918550d15" title="permalink">#</a>
  </h3>
  <p>
    Sometimes, a reviewer will point out various issues with your Pull Request, and you'll agree to address them.
  </p>
  <p>
    This may cause you to add more commits to your Pull Request branch. There's nothing wrong with that per se. However, this <em>can</em> lead to unwarranted thrashing.
  </p>
  <p>
    As an example, your pull request may contain five commits: A, B, C, D, and E. The reviewer doesn't like what you did in commits B and C, so she asks you to remove that code. Most people do that by checking out their pull request branch and deleting the offending code, adding yet another commit (F) to the commit list: [A, B, C, D, E, F]
  </p>
  <p>
    Why should we have to merge a series of commits that first adds unwanted code, and then removes it again? It's just thrashing; it doesn't add any value.
  </p>
  <p>
    Instead, remove the offending commits, and force push your modified branch: [A, D, E]. While under review, you're the sole owner of that branch, so you can modify and force push it all you want.
  </p>
  <p>
    Another example of thrashing that I see a lot is when a Pull Request is becoming old (often due to lengthy discussions): in these cases, the author regularly merges his or her branch with <em>master</em> to keep the Pull Request branch up to date.
  </p>
  <p>
    Again: why do I have to look at all those merge commits? You are the sole owner of that branch. Just <a href="http://git-scm.com/book/en/v2/Git-Branching-Rebasing">rebase</a> your Pull Request branch and force push it. The resulting commit history will be cleaner.
  </p>
  <h3 id="a2341eb3d9e140e993343d6d007d0d26">
    Summary <a href="#a2341eb3d9e140e993343d6d007d0d26" title="permalink">#</a>
  </h3>
  <p>
    One or more persons will review your Pull Request. Don't make your reviewer work.
  </p>
  <p>
    The more you make your reviewer work, the greater the risk is that your Pull Request will be rejected.
  </p>
</div>

<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
  <div class="comment" id="44dc4274a8ac474d9e094bb79de26a57">
    <div class="comment-author"><a href="https://samfrances.co.uk/">Sam Frances</a></div>
    <div class="comment-content">
      <p>
        How do you balance the advice to write small, focused Pull Requests with the practical necessity of sometimes bundling refactoring in with features?
        Especially given the fact that most workplaces inevitably prioritise merging features.
      </p>
    </div>
    <div class="comment-date">2021-06-23 16:03 UTC</div>
  </div>

  <div class="comment" id="2ffe7f88503d495ba8b5292eaa004cbb">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Sam, thank you for writing. Even without refactoring, it's common that a feature is so large that you can't implement it as a single, focused pull request. The best way to address that issue is to hide the work in progress behind a feature flag. You can do the same with refactoring.
      </p>
      <p>
        As Kent Beck puts it:
        <blockquote>
          <p>
            "for each desired change, make the change easy (warning: this may be hard), then make the easy change"
          </p>
          <footer><cite><a href="https://twitter.com/kentbeck/status/250733358307500032">Kent Beck</a></cite></footer>
        </blockquote>
        You may need to first refactor to 'make room' for the new feature. I'd often put that in an isolated pull request and send that first. If anyone complains that I'm doing refactoring work instead of feature work, I'd truthfully respond that I'm doing the refactoring in order to be able to implement the feature.
      </p>
      <p>
        I consider this to be part of being professional. It's how software should be developed, and <a href="/2019/03/18/the-programmer-as-decision-maker">I think that non-technical stakeholders should have little to say about <em>how</em> things are done</a>. You don't have to tell them every little detail about how you write code. You shouldn't have to ask for permission to do this, and you shouldn't have to inform them that that's what you're doing.
      </p>
      <p>
        <a href="/2021/06/14/new-book-code-that-fits-in-your-head">My new book</a> contains a realistic and practical example of a feature developed behind a feature flag.
      </p>
    </div>
    <div class="comment-date">2021-06-27 9:26 UTC</div>
  </div>
</div>
