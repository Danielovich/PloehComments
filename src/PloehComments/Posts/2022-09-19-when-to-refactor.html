---
layout: post
title: "When to refactor"
description: "FAQ: How do I convince my manager to let me refactor?"
date: 2022-09-19 6:36 UTC
tags: [Productivity]
image: "/content/binary/refactor-implement-80-20.png"
image_alt: "A timeline with two sections: Refactor and Implement. The Refactor section is significantly larger than the Implement section."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		This question frequently comes up. Developers want to refactor, but are under the impression that managers or other stakeholders will not let them.
	</p>
	<p>
		Sometimes people ask me how to convince their managers to get permission to refactor. I can't answer that. <a href="/2021/03/22/the-dispassionate-developer">I don't know how to convince other people</a>. That's not my métier.
	</p>
	<p>
		I also believe that professional programmers <a href="/2019/03/18/the-programmer-as-decision-maker">should make their own decisions</a>. You don't ask permission to add three lines to a file, or create a new class. Why do you feel that you have to ask permission to refactor?
	</p>
	<h3 id="4af4356cd706457ebf8968e92850b140">
		Does refactoring take time? <a href="#4af4356cd706457ebf8968e92850b140" title="permalink">#</a>
	</h3>
	<p>
		In <a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a> I tell the following story:
	</p>
	<blockquote>
		<p>
			"I once led an effort to <a href="/ref/ddd">refactor towards deeper insight</a>. My colleague and I had identified that the key to implementing a new feature would require changing a fundamental class in our code base.
		</p>
		<p>
			"While such an insight rarely arrives at an opportune time, we wanted to make the change, and our manager allowed it.
		</p>
		<p>
			"A week later, our code still didn’t compile.
		</p>
		<p>
			"I’d hoped that I could make the change to the class in question and then <a href="/ref/welc">lean on the compiler</a> to identify the call sites that needed modification. The problem was that there was an abundance of compilation errors, and fixing them wasn’t a simple question of search-and-replace.
		</p>
		<p>
			"My manager finally took me aside to let me know that he wasn’t satisfied with the situation. I could only concur.
		</p>
		<p>
			"After a mild dressing down, he allowed me to continue the work, and a few more days of heroic effort saw the work completed.
		</p>
		<p>
			"That’s a failure I don’t intend to repeat."
		</p>
		<footer><cite><a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a></cite></footer>
	</blockquote>
	<p>
		There's a couple of points to this story. Yes, I <em>did</em> ask for permission before refactoring. I expected the process to take time, and I felt that making such a choice of prioritisation should involve my manager. While this manager trusted me, I felt a moral obligation to be transparent about the work I was doing. I didn't consider it professional to take a week out of the calendar and work on one thing while the rest of the organisation was expecting me to be working on something else.
	</p>
	<p>
		So I can understand why developers feel that they have to ask permission to refactor. After all, refactoring takes time... Doesn't it?
	</p>
	<h3 id="ddb8e36130fe475da5ea914ccf06ae45">
		Small steps <a href="#ddb8e36130fe475da5ea914ccf06ae45" title="permalink">#</a>
	</h3>
	<p>
		This may unearth the underlying assumption that prevents developers from refactoring: The notion that refactoring takes time.
	</p>
	<p>
		As I wrote in <a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a>, that was a failure I didn't intend to repeat. I've never again asked permission to refactor, because I've never since allowed myself to be in a situation where refactoring would take significant time.
	</p>
	<p>
		The reason I tell the story in the book is that I use it to motivate using the <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">Strangler pattern</a> at the code level. The book proceeds to show an example of that.
	</p>
	<p>
		Migrating code to a new API by allowing the old and the new to coexist for a while is only one of many techniques for taking smaller steps. Another is the use of <a href="https://en.wikipedia.org/wiki/Feature_toggle">feature flags</a>, a technique that I also show in the book. <a href="https://martinfowler.com/">Martin Fowler</a>'s <a href="/ref/refactoring">Refactoring</a> is literally an entire book about how to improve code bases in small, controlled steps.
	</p>
	<p>
		Follow the <a href="/2019/10/21/a-red-green-refactor-checklist">red-green-refactor checklist</a> and commit after each <em>green</em> and <em>refactor</em> step. Move in small steps and <a href="https://stackoverflow.blog/2022/04/06/use-git-tactically/">use Git tactically</a>.
	</p>
	<p>
		I'm beginning to realise, though, that <em>moving in small steps</em> is a skill that must be explicitly learned. This may seem obvious once posited, but it may also be helpful to explicitly state it.
	</p>
	<p>
		Whenever I've had a chance to talk to other software professionals and <a href="https://twitter.com/hillelogram/status/1445435617047990273">thought leaders</a>, they agree. As far as I can tell, universities and coding boot camps don't teach this skill, and if (like me) you're autodidact, you probably haven't learned it either. After all, few people insist that this is an important skill. It may, however, be one of the most important programming skills you can learn.
	</p>
	<h3 id="11afa6718a3c4a6f8e50aa5066474ac8">
		Make it work, then make it right <a href="#11afa6718a3c4a6f8e50aa5066474ac8" title="permalink">#</a>
	</h3>
	<p>
		When should you refactor? As <a href="https://wiki.c2.com/?BoyScoutRule">the boy scout rule</a> suggests: All the time.
	</p>
	<p>
		You can, specifically, do it after implementing a new feature. As <a href="https://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast">Kent Beck perhaps said or wrote</a>: <em>Make it work, then make it right</em>.
	</p>
	<p>
		How long does it take to make it right?
	</p>
	<p>
		Perhaps you think that it takes as much time as it does to make it work.
	</p>
	<p>
		<img src="/content/binary/make-it-work-then-right-50-50.png" alt="A timeline with two sections: 'make it work' and 'make it right'. Each section has the same size.">
	</p>
	<p>
		Perhaps you think that making it right takes even more time.
	</p>
	<p>
		<img src="/content/binary/make-it-work-then-right-20-80.png" alt="A timeline with two sections: 'make it work' and 'make it right'. The 'make it right' section is substantially larger than the 'make it work' section.">
	</p>
	<p>
		If this is how much time making the code right takes, I can understand why you feel that you need to ask your manager. That's what I did, those many years ago. But what if the proportions are more like this?
	</p>
	<p>
		<img src="/content/binary/make-it-work-then-right-80-20.png" alt="A timeline with two sections: 'make it work' and 'make it right'. The 'make it right' section is substantially smaller than the 'make it work' section.">
	</p>
	<p>
		Do you still feel that you need to ask for permission to refactor?
	</p>
	<p>
		Writing code so that the team can keep a sustainable pace is your job. It's not something you should have to ask for permission to do.
	</p>
	<blockquote>
		<p>
			"Any fool can write code that a computer can understand. Good programmers write code that humans can understand."
		</p>
		<footer><cite>Martin Fowler, <a href="/ref/refactoring">Refactoring</a></cite></footer>
	</blockquote>
	<p>
		Making the code right is not always a huge endeavour. It can be, if you've already made a mess of it, but if it's in good condition, keeping it that way doesn't have to take much extra effort. It's part of the ongoing design process that programming is.
	</p>
	<p>
		How do you know what <em>right</em> is? Doesn't this make-it-work-make-it-right mentality lead to <a href="https://wiki.c2.com/?SpeculativeGenerality">speculative generality</a>?
	</p>
	<p>
		No-one expects you to be able to predict the future, so don't try. Making it right means making the code good in the current context. Use good names, remove duplication, get rid of code smells, keep methods small and complexity low. <a href="/2020/04/13/curb-code-rot-with-thresholds">Refactor if you exceed a threshold</a>.
	</p>
	<h3 id="1a2eb1f23d70440c84e518babf7dc373">
		Make code easy to change <a href="#1a2eb1f23d70440c84e518babf7dc373" title="permalink">#</a>
	</h3>
	<p>
		The purpose of keeping code in a good condition is to make future changes as easy as possible. If you can't predict the future, however, then how do you know how to factor the code?
	</p>
	<p>
		Another <a href="https://en.wikipedia.org/wiki/Kent_Beck">Kent Beck</a> aphorism suggests a tactic:
	</p>
	<blockquote>
		<p>
			"for each desired change, make the change easy (warning: this may be hard), then make the easy change"
		</p>
		<footer><cite><a href="https://twitter.com/KentBeck/status/250733358307500032">Kent Beck</a></cite></footer>
	</blockquote>
	<p>
		In other words, when you know what you need to accomplish, first refactor the code so that it becomes easier to achieve the goal, and only then write the code to do that.
	</p>
	<p>
		<img src="/content/binary/refactor-implement-40-60.png" alt="A timeline with two sections: Refactor and Implement. The Implement section is visibly larger than the Refactor section.">
	</p>
	<p>
		Should you ask permission to refactor in such a case? Only if you sincerely believe that you can complete the entire task significantly faster without first improving the code. How likely is that? If the code base is already a mess, how easy is it to make changes? Not easy, and granted: That will also be true for refactoring. The difference between first refactoring and <em>not</em> refactoring, however, is that if you refactor, you leave the code in a better state. If you don't, you leave it in a worse state.
	</p>
	<p>
		These decisions compound.
	</p>
	<p>
		But what if, as Kent Beck implies, refactoring is hard? Then the situation might look like this:
	</p>
	<p>
		<img src="/content/binary/refactor-implement-80-20.png" alt="A timeline with two sections: Refactor and Implement. The Refactor section is significantly larger than the Implement section.">
	</p>
	<p>
		Should you ask for permission to refactor? I don't think so. While refactoring in this diagram is most of the work, it makes the change easy. Thus, once you're done refactoring, you make the easy change. The total amount of time this takes may turn out to be quicker than if you hadn't refactored (compare this figure to the previous figure: they're to scale). You also leave the code base in a better state so that future changes may be easier.
	</p>
	<h3 id="ff4ce77459af4e64a9e3df797fc01d8d">
		Conclusion <a href="#ff4ce77459af4e64a9e3df797fc01d8d" title="permalink">#</a>
	</h3>
	<p>
		There are lots of opportunities for refactoring. Every time you see something that could be improved, why not improve it? The fact that you're already looking at a piece of code suggests that it's somehow relevant to your current task. If it takes ten, fifteen minutes to improve it, why not do it? What if it takes an hour?
	</p>
	<p>
		Most people think nothing of spending hours in meetings without asking their managers. If this is true, you can also decide to use a couple of hours improving code. They're likely as well spent as the meeting hours.
	</p>
	<p>
		The key, however, is to be able to perform opportunistic refactoring. You can't do that if you can only move in day-long iterations; if hours, or days, go by when you can't compile, or when most tests fail.
	</p>
	<p>
		On the other hand, if you're able to incrementally improve the code base in one-minute, or fifteen-minute, steps, then you can improve the code base every time an occasion arrives.
	</p>
	<p>
		This is a skill that you need to learn. You're not born with the ability to improve in small steps. You'll have to practice - for example by <a href="/2020/01/13/on-doing-katas">doing katas</a>. One customer of mine told me that they found Kent Beck's <a href="https://medium.com/@kentbeck_7670/test-commit-revert-870bbd756864">TCR</a> a great way to teach that skill.
	</p>
	<p>
		You can refactor in small steps. It's part of software engineering. Usually, you don't need to ask for permission.
	</p>
</div>
<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>

  <div class="comment" id="4dc52487bcee4459857d6fb6741dbcad">
    <div class="comment-author"><a href="https://danielt1263.medium.com">Daniel Tartaglia</a></div>
    <div class="comment-content">
      <p>
				I've always had a problem with the notion of "red, green, refactor" and "first get it working, then make it right." I think the order is completely wrong.
			</p>
      <p>
				As an explanation, I refer you to the first chapter of the first edition of Martin Fowler's Refactoring book. In that chapter is an example of a working system and we are presented with a change request. 
			</p>
      <p>
				In the example, the first thing that Fowler points out and does is the refactoring. And one of the highlighted ideas in the chapter says:
				<blockquote>When you find you have to add a feature to a program, and the program's code is not structured in a convenient way to add the feature, first refactor the program to make it easy to add the feature, then add the feature.</blockquote>
      </p>
      <p>
				In other words, the refactoring <i>comes first</i>. You refactor as part of adding the feature, not as a separate thing that is done after you have working code. It may not trip off the tongue as nicely, but the saying should be "refactor, red, green."
		</p>
      <p>
				Once you have working code, you are done, and when you are estimating the time it will take to add the feature, <i>you include the refactoring time</i>. Lastly, you never refactor "just because," you refactor in order to make a new feature easy to add.
		</p>
		<p>
			This mode of working makes much more sense to me. I feel that refactoring with no clear goal in mind ("improve the design" is not a clear goal) just leads to an over-designed/unnecessarily complex system. What do you think of this idea?
		</p>
    </div>
    <div class="comment-date">2022-09-24 02:28 UTC</div>
  </div>

  <div class="comment" id="f9df3a46ce5f4cb8a386304f64030137">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Daniel, thank you for writing. You make some good points.
      </p>
      <p>
      	The red-green-refactor cycle is useful as a feedback cycle for new development work. It's not the only way to work. Particularly, as you point out, when you have existing code, first refactoring and then adding new code is a useful order.
      </p>
      <p>
      	Typically, though, when you're adding a new feature, you can rarely implement a new feature <em>only</em> by refactoring existing code. Normally you also need to add some new code. I still find the red-green-refactor cycle useful for that kind of work. I don't view it as an <em>either-or</em> proposition, but rather as a <em>both-this-and-that</em> way of working.
      </p>
      <blockquote>
      	<p>
      		"you never refactor "just because," you refactor in order to make a new feature easy to add."
      	</p>
      </blockquote>
      <p>
      	Never say never. I don't agree with that point of view. There are more than one reason for refactoring, and making room for a new feature is certainly one of them. This does not, however, rule out other reasons. I can easily think of a handful of other reasons that I consider warranted, but I don't want to derail the discussion by listing all of them. The list is not going to be complete anyway. I'll just outline one:
      </p>
      <p>
      	Sometimes, you read existing code because you need to understand what's going on. If the code is badly structured, it can take significant time and effort to reach such understanding. If, at that point you can see a simpler way to achieve the same behaviour, why not refactor the code? In that way, you make it easier for future readers of the code to understand what's going on. If you've already spent (wasted) significant time understanding something, why let other readers suffer and waste time if you can simplify the code?
      </p>
      <p>
      	This is essentially the boy scout rule, but as I claimed, there are other reasons to refactor as well.
      </p>
      <p>
      	Finally, thank you for the quote from <em>Refactoring</em>. I've usually been using this Kent Beck quote:
      </p>
      <blockquote>
      	<p>
      		"for each desired change, make the change easy (warning: this may be hard), then make the easy change"
      	</p>
      	<footer><cite><a href="https://twitter.com/kentbeck/status/250733358307500032">Kent Beck</a></cite></footer>
      </blockquote>
      <p>
      	but that's from 2012, and <em>Refactoring</em> is from 1999. It's such a Kent Beck thing to say, though, and Kent is a coauthor of <em>Refactoring</em>, so who knows who came up with that. I'm happy to know of the earlier quote, though.
      </p>
    </div>
    <div class="comment-date">2022-10-02 18:19 UTC</div>
  </div>

	<div class="comment" id="d2f99d2cf0d2471ea591103b9eda7e9a">
		<div class="comment-author"><a href="https://about.me/tysonwilliams">Tyson Williams</a></div>
		<div class="comment-content">
			<blockquote>
				I don't view it as an either-or proposition, but rather as a both-this-and-that way of working.
			</blockquote>
			<p>
				I think it is worth elaborating on this.  I think am correct in saying that Mark believes that type-driven development and test-driven development are a both-this-and-that way of working instead of an either-or way of working.  He did exactly this in his <a href="https://www.pluralsight.com/courses/fsharp-type-driven-development">Pluralsight course titled Type-Driven Development with F#</a> by first obtaining an implementation using type-driven development and then <i>deleting his implementation</i> but keeping his types and obtaining a second implementation using test-driven development.
			</p>
			<p>
				When implementing a new feature, it is important to as quickly as possible derisk by discovering any surprises (aka unknown unknowns) and analyze all challenges (aka known unknowns).  The reason for this is to make sure the intended approach is feasible.  During this phase of work, we are in the "green" step of test-driven development.  Anything goes.  There are no rules.  The code can horribly ugly or unmaintainable.  Just get the failing test to pass.
			</p>
			<p>
				After the test passes, you have proved that the approach is sound.  Now you need to share your solution with others.  Here is where refactoring first occurs.  Just like in Mark's course, I often find it helpful to <i>start over</i>.  Now that I know where I am going, I can first refactor the code to make the functional change, which I know will make the test pass.  In this way, I know that all my refactors have a clear goal.
			</p>
			<blockquote>
				You refactor as part of adding the feature, not as a separate thing that is done after you have working code.
			</blockquote>
			<p>
				I agree that refactoring should be done as part of the feature, but I disagree that it should (always) be done before you have working code.  It is often done after you have working code.
			</p>
			<blockquote>
				Once you have working code, you are done, and when you are estimating the time it will take to add the feature, <i>you include the refactoring time</i>.
			</blockquote>
			<p>
				I agree that estimating should include the refactoring time, but I disagree that you are done when you have working code.  When you have working code, you are approximately halfway done.  Your code is currently optimized for writing.  You still need to optimize it for reading.
			</p>
		</div>
		<div class="comment-date">2022-10-08 17:42 UTC</div>
	</div>
</div>
