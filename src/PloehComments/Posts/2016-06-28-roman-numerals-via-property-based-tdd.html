---
layout: post
title: "Roman numerals via property-based TDD"
description: "An example of doing the Roman numerals kata with property-based test-driven development."
date: 2016-06-28 07:28 UTC
tags: [Unit Testing, F#, FsCheck, Property-based Testing]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		The <em>Roman numerals</em> kata is a simple programming exercise. You should implement conversion to and from <a href="https://en.wikipedia.org/wiki/Roman_numerals">Roman numerals</a>. This always struck me as the ultimate case for example-driven development, but I must also admit that I've managed to get stuck on the exercise doing exactly that: throwing more and more examples at the problem. Prompted by previous successes with property-based testing, I wondered whether the problem would be more tractable if approached with property-based testing. This turned out to be the case.
	</p>
	<h3 id="0e88815de35b4edba4bf39b92b99c79f">
		Single values <a href="#0e88815de35b4edba4bf39b92b99c79f" title="permalink">#</a>
	</h3>
	<p>
		When modelling a problem with property-based testing, you should attempt to express it in terms of general rules, but even so, the fundamental rule of Roman numerals is that there are certain singular symbols that have particular numeric values. There are no overall principles guiding these relationships; they simply are. Therefore, you'll still need to express these singular values as particular values. This is best done with a simple parametrised test, here using <a href="http://xunit.github.io">xUnit.net 2.1</a>:
	</p>
	<p>
		<pre>[&lt;<span style="color:#4ec9b0;">Theory</span>&gt;]
[&lt;<span style="color:#4ec9b0;">InlineData</span>(<span style="color:#a31515;">&quot;I&quot;</span>,&nbsp;&nbsp;&nbsp;&nbsp;1)&gt;]
[&lt;<span style="color:#4ec9b0;">InlineData</span>(<span style="color:#a31515;">&quot;V&quot;</span>,&nbsp;&nbsp;&nbsp;&nbsp;5)&gt;]
[&lt;<span style="color:#4ec9b0;">InlineData</span>(<span style="color:#a31515;">&quot;X&quot;</span>,&nbsp;&nbsp;&nbsp;10)&gt;]
[&lt;<span style="color:#4ec9b0;">InlineData</span>(<span style="color:#a31515;">&quot;L&quot;</span>,&nbsp;&nbsp;&nbsp;50)&gt;]
[&lt;<span style="color:#4ec9b0;">InlineData</span>(<span style="color:#a31515;">&quot;C&quot;</span>,&nbsp;&nbsp;100)&gt;]
[&lt;<span style="color:#4ec9b0;">InlineData</span>(<span style="color:#a31515;">&quot;D&quot;</span>,&nbsp;&nbsp;500)&gt;]
[&lt;<span style="color:#4ec9b0;">InlineData</span>(<span style="color:#a31515;">&quot;M&quot;</span>,&nbsp;1000)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``elemental&nbsp;symbols&nbsp;have&nbsp;correct&nbsp;values``</span>&nbsp;(symbol&nbsp;:&nbsp;<span style="color:#4ec9b0;">string</span>)&nbsp;expected&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">Some</span>&nbsp;expected&nbsp;=!&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">tryParseRoman</span>&nbsp;symbol</pre>
	</p>
	<p>
		The <code>=!</code> operator is a custom operator defined by <a href="http://www.swensensoftware.com/unquote">Unquote</a> (3.1.1), an assertion library. You can read it as <em>must equal</em>; that is, you can read this particular assertion as <em>some expected must equal tryParseRoman symbol</em>.
	</p>
	<p>
		As you can see, this simple test expresses the relationship between the singular Roman numeral values and their decimal counterparts. You might still consider this automated test as example-driven, but I more think about it as establishing the ground rules for how Roman numerals work. If you look at <a href="https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system">the Wikipedia article</a>, for instance, it also starts explaining the system by listing the values of these seven symbols.
	</p>
	<h3 id="7539ed1043884b22a0372e7193d3eaba">
		Round-tripping <a href="#7539ed1043884b22a0372e7193d3eaba" title="permalink">#</a>
	</h3>
	<p>
		A common technique when applying property-based testing to parsing problems is to require that values can round-trip. This should also be the case here:
	</p>
	<p>
		<pre><span style="color:blue;">let</span>&nbsp;romanRange&nbsp;=&nbsp;<span style="color:#4ec9b0;">Gen</span>.<span style="color:navy;">elements</span>&nbsp;[1..3999]&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Arb</span>.<span style="color:navy;">fromGen</span>
 
[&lt;<span style="color:#4ec9b0;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``tryParse&nbsp;is&nbsp;the&nbsp;inverse&nbsp;of&nbsp;toRoman``</span>&nbsp;()&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">Prop</span>.<span style="color:navy;">forAll</span>&nbsp;romanRange&nbsp;&lt;|&nbsp;<span style="color:blue;">fun</span>&nbsp;i&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">test</span>&nbsp;<span style="background:yellow;">&lt;@&nbsp;</span><span style="color:navy;background:yellow;">Some</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">i</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">=</span><span style="background:yellow;">&nbsp;(</span><span style="background:yellow;">i</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">|&gt;</span><span style="background:yellow;">&nbsp;</span><span style="color:#4ec9b0;background:yellow;">Numeral</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">toRoman</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:yellow;">|&gt;</span><span style="background:yellow;">&nbsp;</span><span style="color:#4ec9b0;background:yellow;">Option</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">bind</span><span style="background:yellow;">&nbsp;</span><span style="color:#4ec9b0;background:yellow;">Numeral</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">tryParseRoman</span><span style="background:yellow;">)&nbsp;@&gt;</span></pre>
	</p>
	<p>
		This property uses <a href="http://fscheck.github.io/FsCheck">FsCheck</a> (2.2.4). First, it expresses a range of relevant integers. For various reasons (that we'll return to) we're only going to attempt conversion of the integers between 1 and 3,999. The value <code>romanRange</code> has the type Arbitrary&lt;int&gt;, where Arbitrary&lt;'a&gt; is a type defined by FsCheck. You can think of it as a generator of random values. In this case, <code>romanRange</code> generates random integers between 1 and 3,999.
	</p>
	<p>
		When used with Prop.forAll, the property states that for all values drawn from romanRange, the anonymous function should succeed. The <code>i</code> argument within that anonymous function is populated by <code>romanRange</code>, and the function is executed 100 times (by default).
	</p>
	<p>
		The <code>test</code> function is another Unquote function. It evaluates and reports on the quoted boolean expression; if it evaluates to true, nothing happens, but it throws an exception if it evaluates to false.
	</p>
	<p>
		The particular expression states that if you call toRoman with <code>i</code>, and then call tryParseRoman with the return value of that function call, the result should be equal to <code>i</code>. Both sides should be wrapped in a Some case, though, since both toRoman and tryParseRoman might also return None. For the values in romanRange, however, you'd expect that the round-trip always succeeds.
	</p>
	<h3 id="01b708fc05b84a119ed6450b81c75935">
		Additivity <a href="#01b708fc05b84a119ed6450b81c75935" title="permalink">#</a>
	</h3>
	<p>
		The fundamental idea about Roman numerals is that they are additive: I means 1, II means (1 + 1 =) 2, XXX means (10 + 10 + 10 =) 30, and MLXVI means (1000 + 50 + 10 + 5 + 1 =) 1066. You simply count and add. Yes, there are special rules for subtractive shorthand, but forget about those for a moment. If you have a Roman numeral with symbols in strictly descending order, you can simply add the symbol values together.
	</p>
	<p>
		You can express this with FsCheck. It looks a little daunting, but actually isn't that bad. I'll show it first, and then walk you through it:
	</p>
	<p>
		<pre>[&lt;<span style="color:#4ec9b0;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``symbols&nbsp;in&nbsp;descending&nbsp;order&nbsp;are&nbsp;additive``</span>&nbsp;()&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">stringRepeat</span>&nbsp;char&nbsp;count&nbsp;=&nbsp;<span style="color:#4ec9b0;">String</span>&nbsp;(char,&nbsp;count)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">genSymbols</span>&nbsp;count&nbsp;symbol&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0..count]&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">List</span>.<span style="color:navy;">map</span>&nbsp;(<span style="color:navy;">stringRepeat</span>&nbsp;symbol)&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Gen</span>.<span style="color:navy;">elements</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;thousands&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">genSymbols</span>&nbsp;3&nbsp;<span style="color:#a31515;">&#39;M&#39;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;fiveHundreds&nbsp;=&nbsp;<span style="color:navy;">genSymbols</span>&nbsp;1&nbsp;<span style="color:#a31515;">&#39;D&#39;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;hundreds&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">genSymbols</span>&nbsp;3&nbsp;<span style="color:#a31515;">&#39;C&#39;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;fifties&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">genSymbols</span>&nbsp;1&nbsp;<span style="color:#a31515;">&#39;L&#39;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;tens&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">genSymbols</span>&nbsp;3&nbsp;<span style="color:#a31515;">&#39;X&#39;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;fives&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">genSymbols</span>&nbsp;1&nbsp;<span style="color:#a31515;">&#39;V&#39;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;ones&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">genSymbols</span>&nbsp;3&nbsp;<span style="color:#a31515;">&#39;I&#39;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;symbols&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[thousands;&nbsp;fiveHundreds;&nbsp;hundreds;&nbsp;fifties;&nbsp;tens;&nbsp;fives;&nbsp;ones]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Gen</span>.<span style="color:navy;">sequence</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Gen</span>.<span style="color:navy;">map</span>&nbsp;<span style="color:#4ec9b0;">String</span>.<span style="color:navy;">Concat</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Arb</span>.<span style="color:navy;">fromGen</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">Prop</span>.<span style="color:navy;">forAll</span>&nbsp;symbols&nbsp;&lt;|&nbsp;<span style="color:blue;">fun</span>&nbsp;s&nbsp;<span style="color:blue;">-&gt;</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">tryParseRoman</span>&nbsp;s
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;expected&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Seq</span>.<span style="color:navy;">map</span>&nbsp;(<span style="color:navy;">string</span>&nbsp;&gt;&gt;&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">tryParseRoman</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Seq</span>.<span style="color:navy;">choose</span>&nbsp;<span style="color:navy;">id</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Seq</span>.<span style="color:navy;">sum</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:navy;">Some</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=!&nbsp;actual</pre>
	</p>
	<p>
		The first two lines are two utility functions. The function <code>stringRepeat</code> has the type <code>char -&gt; int -&gt; string</code>. It simply provides a curried form of the String constructor overload that enables you to repeat a particular char value. As an example, <code>stringRepeat 'I' 0</code> is "", <code>stringRepeat 'X' 2</code> is "XX", and so on.
	</p>
	<p>
		The function <code>genSymbols</code> has the type <code>int -&gt; char -&gt; Gen&lt;string&gt;</code>. It returns a generator that produces a repeated string no longer than the specified length. Thus, <code>genSymbols 3 'M'</code> is a generator that draws random values from the set [""; "M"; "MM"; "MMM"], <code>genSymbols 1 'D'</code> is a generator that draws random values from the set [""; "D"], and so on. Notice that the empty string is one of the values that the generator may use. This is by design.
	</p>
	<p>
		Using genSymbols, you can define generators for all the symbols: up to three thousands, up to one five hundreds, up to three hundreds, etc. <code>thousands</code>, <code>fiveHundreds</code>, <code>hundreds</code>, and so on, are all values of the type Gen&lt;string&gt;.
	</p>
	<p>
		You can combine all these string generators to a single generator using Gen.sequence, which takes a seq&lt;Gen&lt;'a&gt;&gt; as input and returns a Gen&lt;'a list&gt;. In this case, the input is [thousands; fiveHundreds; hundreds; fifties; tens; fives; ones], which has the type <code>Gen&lt;string&gt; list</code>, so the output is a <code>Gen&lt;string list&gt;</code> value. Values generated could include ["MM"; ""; ""; ""; "X"; ""; ""], [""; "D"; "CC"; "L"; "X"; "V"; ""], and so on.
	</p>
	<p>
		Instead of lists of strings, you need single string values. These are easy to create using the built-in method String.Concat. You have to do it within a Gen value, though, so it's <code>Gen.map String.Concat</code>. Finally, you can convert the resulting Gen&lt;string&gt; to an Arbitrary using Arb.fromGen. The final <code>symbols</code> value has the type Arbitrary&lt;string&gt;. It'll generate values such as "MMX" and "DCCLXV".
	</p>
	<p>
		This is a bit of work to ensure that proper Roman numerals are generated, but the rest of the property is tractable. You can use FsCheck's Prop.forAll to express the property that when tryParseRoman is called with any of the generated numerals, the return value is equal to the expected value.
	</p>
	<p>
		The expected value is the sum of the value of each of the symbols in the input string, <code>s</code>. The <code>string</code> type implements the interface <code>char seq</code>, so you can map each of the characters by invoking tryParseRoman. That gives you a <cdata>seq&lt;int option&gt;</cdata>, because tryParseRoman returns <code>int option</code> values. You can use <code>Seq.choose id</code> to throw away any None values there may be, and then <code>Seq.sum</code> to calculate the sum of the integers. Finally, you can pipe the sum into the Some case constructor to turn <code>expected</code> into an <code>int option</code>, which matches the type of <code>actual</code>.
	</p>
	<p>
		Now that you have <code>expected</code> and <code>actual</code> values, you can assert that these two values must be equal to each other. This property states that for all strictly descending numerals, the return value must be the sum of the constituent symbols.
	</p>
	<h3 id="151d6efa45574320a3c33ad4aedd8a59">
		Subtractiveness <a href="#151d6efa45574320a3c33ad4aedd8a59" title="permalink">#</a>
	</h3>
	<p>
		The principal rule for Roman numerals is that of additivity, but if you only apply the above rules, you'd allow numerals such as IIII for 4, LXXXX for 90, etc. While there's historical precedent for such notation, it's not allowed in 'modern' Roman numerals. If there are more than three repeated characters, you should instead prefer subtractive notation: IV for 4, XC for 90, and so on.
	</p>
	<p>
		Subtractive notation is, however, only allowed within adjacent groups. Logically, you could write 1999 as MIM, but this isn't allowed. The symbol I can only be used to subtract from V and X, X can only subtract from L and C, and C can only subtract from D and M.
	</p>
	<p>
		Within these constraints, you have to describe the property of subtractive notation. Here's one way to do it:
	</p>
	<p>
		<pre><span style="color:blue;">type</span>&nbsp;<span style="color:#4ec9b0;">OptionBuilder</span>()&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">member</span>&nbsp;this.<span style="color:navy;">Bind</span>(v,&nbsp;<span style="color:navy;">f</span>)&nbsp;=&nbsp;<span style="color:#4ec9b0;">Option</span>.<span style="color:navy;">bind</span>&nbsp;<span style="color:navy;">f</span>&nbsp;v
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">member</span>&nbsp;this.<span style="color:navy;">Return</span>&nbsp;v&nbsp;=&nbsp;<span style="color:navy;">Some</span>&nbsp;v
 
<span style="color:blue;">let</span>&nbsp;opt&nbsp;=&nbsp;<span style="color:#4ec9b0;">OptionBuilder</span>()
 
[&lt;<span style="color:#4ec9b0;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``certain&nbsp;symbols&nbsp;in&nbsp;ascending&nbsp;are&nbsp;subtractive``</span>&nbsp;()&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">subtractive</span>&nbsp;(subtrahend&nbsp;:&nbsp;<span style="color:#4ec9b0;">char</span>)&nbsp;(minuends&nbsp;:&nbsp;<span style="color:#4ec9b0;">string</span>)&nbsp;=&nbsp;<span style="color:blue;">gen</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let!</span>&nbsp;minuend&nbsp;=&nbsp;<span style="color:#4ec9b0;">Gen</span>.<span style="color:navy;">elements</span>&nbsp;minuends
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;subtrahend,&nbsp;minuend&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;symbols&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">Gen</span>.<span style="color:navy;">oneof</span>&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">subtractive</span>&nbsp;<span style="color:#a31515;">&#39;I&#39;</span>&nbsp;<span style="color:#a31515;">&quot;VX&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">subtractive</span>&nbsp;<span style="color:#a31515;">&#39;X&#39;</span>&nbsp;<span style="color:#a31515;">&quot;LC&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">subtractive</span>&nbsp;<span style="color:#a31515;">&#39;C&#39;</span>&nbsp;<span style="color:#a31515;">&quot;DM&quot;</span>&nbsp;]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Arb</span>.<span style="color:navy;">fromGen</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">Prop</span>.<span style="color:navy;">forAll</span>&nbsp;symbols&nbsp;&lt;|&nbsp;<span style="color:blue;">fun</span>&nbsp;(subtrahend,&nbsp;minuend)&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;originalRoman&nbsp;=&nbsp;<span style="color:#4ec9b0;">String</span>&nbsp;[|&nbsp;subtrahend;&nbsp;minuend&nbsp;|]
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">tryParseRoman</span>&nbsp;originalRoman
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;roundTrippedRoman&nbsp;=&nbsp;actual&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Option</span>.<span style="color:navy;">bind</span>&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">toRoman</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;expected&nbsp;=&nbsp;<span style="color:blue;">opt</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let!</span>&nbsp;m&nbsp;=&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">tryParseRoman</span>&nbsp;(<span style="color:navy;">string</span>&nbsp;minuend)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let!</span>&nbsp;s&nbsp;=&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">tryParseRoman</span>&nbsp;(<span style="color:navy;">string</span>&nbsp;subtrahend)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;m&nbsp;-&nbsp;s&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=!&nbsp;actual
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">Some</span>&nbsp;originalRoman&nbsp;=!&nbsp;roundTrippedRoman</pre>
	</p>
	<p>
		Like the previous property, this looks like a mouthful, but isn't too bad. I'll walk you through it.
	</p>
	<p>
		Initially, ignore the OptionBuilder type and the opt value; we'll return to them shortly. The property itself starts by defining a function called <code>subtractive</code>, which has the type <code>char -&gt; string -&gt; Gen&lt;char * char&gt;</code>. The first argument is a symbol representing <a href="https://en.wikipedia.org/wiki/Subtraction">the subtrahend</a>; that is: the number being subtracted. The next argument is a sequence of minuends; that is: numbers from which the subtrahend will be subtracted.
	</p>
	<p>
		The <code>subtractive</code> function is implemented with a <code>gen</code> computation expression. It first uses a <code>let!</code> binding to define that a singular minuend is a random value drawn from <code>minuends</code>. As usual, Gen.elements is the workhorse: it defines a generator that randomly draws from a sequence of values, and because <code>minuends</code> is a string, and the string type implements <code>char seq</code>, it can be used with Gen.elements to define a generator of char values. While <code>Gen.elements minuends</code> returns a Gen&lt;char&gt; value, the use of a <code>let!</code> binding within a computation expression causes <code>minuend</code> to have the type <code>char</code>.
	</p>
	<p>
		The second line of code in <code>subtractive</code> returns a tuple of two char values: the subtrahend first, and the minuend second. Normally, when subtracting with the arithmetic minus operator, you'd write a difference as <em>minuend - subtrahend</em>; the minuends comes first, followed by the subtrahend. The Roman subtractive notation, however, is written with the subtrahend before the minuend, which is the reason that the <code>subtractive</code> function returns the symbols in that order. It's easier to think about that way.
	</p>
	<p>
		The <code>subtractive</code> function enables you to define generators of Roman numerals using subtractive notation. Since I can only be used before V and X, you can define a generator using <code>subtractive 'I' "VX"</code>. This is a Gen&lt;char * char&gt; value. Likewise, you can define <code>subtractive 'X' "LC"</code> and <code>subtractive 'C' "DM"</code> and use Gen.oneOf to define a generator that randomly selects one of these generators, and uses the selected generator to produce a value. As always, the last step is to convert the generator into an Arbitrary with Arb.fromGen, so that <code>symbols</code> has the type Arbitrary&lt;char * char&gt;.
	</p>
	<p>
		Equipped with an Arbitrary, you can again use Prop.forAll to express the desired property. First, <code>originalRoman</code> is created from the subtrahend and minuend. Due to the way <code>symbols</code> is defined, <code>originalRoman</code> will have values like "IV", "XC", and so on.
	</p>
	<p>
		The property then proceeds to invoke tryParseRoman. It also uses the <code>actual</code> value to produce a round-tripped value. Not only should the parser correctly understand subtractive notation, but the integer-to-Roman conversion should also prefer this notation.
	</p>
	<p>
		The last part of the property is the assertion. Here, you need <code>opt</code>, which is a <a href="https://msdn.microsoft.com/en-us/library/dd233182.aspx">computation builder</a> for option values.
	</p>
	<p>
		In the assertion, you need to calculate the expected value. Both minuend and subtrahend are char values; in order to find their corresponding decimal values, you'll need to call tryParseRoman. The problem is that tryParseRoman returns an <code>int option</code>. For example, <code>tryParseRoman "I"</code> returns <code>Some 1</code>, so you may need to subtract <code>Some 1</code> from <code>Some 5</code>. The most readable way I've found is to use a computation expression. Using <code>let!</code> bindings, both <code>m</code> and <code>s</code> are <code>int</code> values, which you can easily subtract using the normal <code>-</code> operator.
	</p>
	<p>
		<code>expected</code> and <code>actual</code> are both <code>int option</code> values, so can be compared using Unquote's <em>must equal</em> operator.
	</p>
	<p>
		Finally, the property also asserts that the original value must be equal to the round-tripped value. If not, you could have an implementation that correctly parses "IV" as 4, but converts 4 to "IIII".
	</p>
	<h3 id="49291a911a82471d825d690b5a47f2b4">
		Limited repetition <a href="#49291a911a82471d825d690b5a47f2b4" title="permalink">#</a>
	</h3>
	<p>
		The previous property only ensures that subtractive notation is used in simple cases, like IX or CD. It doesn't verify that composite numerals are correctly written. As an example, the converter should convert 1893 to MDCCCXCIII, not MDCCCLXXXXIII. The second alternative is incorrect because it uses LXXXX to represent 90, instead of XC.
	</p>
	<p>
		The underlying property is that any given symbol can only be repeated at most three times. A symbol can appear more than thrice in total, as demonstrated by the valid numeral MDCCCXCIII, in which C appears four times. For any group of repeated characters, however, a character must only be repeated once, twice, or thrice.
	</p>
	<p>
		This also explain why the maximum Roman numeral is MMMCMXCIX, or 3,999.
	</p>
	<p>
		In order to express this property in code, you first need a function to group characters. Here, I've chosen to reuse <a href="http://stackoverflow.com/a/35055165/126014">one of my own creation</a>:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;seq&lt;&#39;a&gt;&nbsp;-&gt;&nbsp;&#39;a&nbsp;list&nbsp;list&nbsp;when&nbsp;&#39;a&nbsp;:&nbsp;equality</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">group</span>&nbsp;xs&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">folder</span>&nbsp;x&nbsp;=&nbsp;<span style="color:blue;">function</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;[]&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[[x]]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(h<span style="color:navy;">::</span>t)<span style="color:navy;">::</span>ta&nbsp;<span style="color:blue;">when</span>&nbsp;h&nbsp;=&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;(x<span style="color:navy;">::</span>h<span style="color:navy;">::</span>t)<span style="color:navy;">::</span>ta
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;acc&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[x]<span style="color:navy;">::</span>acc
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">Seq</span>.<span style="color:navy;">foldBack</span>&nbsp;<span style="color:navy;">folder</span>&nbsp;xs&nbsp;[]</pre>
	</p>
	<p>
		This function will, for example, group "MDCCCXCIII" like this:
	</p>
	<p>
		<pre>&gt; "MDCCCXCIII" |&gt; group;;
val it : char list list =
  [['M']; ['D']; ['C'; 'C'; 'C']; ['X']; ['C']; ['I'; 'I'; 'I']]</pre>
	</p>
	<p>
		All you need to do is to find the length of all such sub-lists, and assert that the maximum is at most 3:
	</p>
	<p>
		<pre>[&lt;<span style="color:#4ec9b0;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``there&nbsp;can&nbsp;be&nbsp;no&nbsp;more&nbsp;than&nbsp;three&nbsp;identical&nbsp;symbols&nbsp;in&nbsp;a&nbsp;row``</span>&nbsp;()&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">Prop</span>.<span style="color:navy;">forAll</span>&nbsp;romanRange&nbsp;&lt;|&nbsp;<span style="color:blue;">fun</span>&nbsp;i&nbsp;<span style="color:blue;">-&gt;</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">toRoman</span>&nbsp;i
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">test</span>&nbsp;<span style="background:yellow;">&lt;@&nbsp;</span><span style="background:yellow;">actual</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:yellow;">|&gt;</span><span style="background:yellow;">&nbsp;</span><span style="color:#4ec9b0;background:yellow;">Option</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">map</span><span style="background:yellow;">&nbsp;(</span><span style="color:navy;background:yellow;">group</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">&gt;&gt;</span><span style="background:yellow;">&nbsp;(</span><span style="color:#4ec9b0;background:yellow;">List</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">map</span><span style="background:yellow;">&nbsp;</span><span style="color:#4ec9b0;background:yellow;">List</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">length</span><span style="background:yellow;">)&nbsp;</span><span style="background:yellow;">&gt;&gt;</span><span style="background:yellow;">&nbsp;</span><span style="color:#4ec9b0;background:yellow;">List</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">max</span><span style="background:yellow;">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:yellow;">|&gt;</span><span style="background:yellow;">&nbsp;</span><span style="color:#4ec9b0;background:yellow;">Option</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">exists</span><span style="background:yellow;">&nbsp;(</span><span style="color:blue;background:yellow;">fun</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">x</span><span style="background:yellow;">&nbsp;</span><span style="color:blue;background:yellow;">-&gt;</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">x</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">&lt;=</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">3</span><span style="background:yellow;">)&nbsp;@&gt;</span></pre>
	</p>
	<p>
		Since <code>actual</code> is a <code>string option</code>, you need to express the assertion within the Maybe (Option) monad. First, you can use Option.map to map any value (should there be one) to find the maximum length of any repeated character group. This returns an <code>int option</code>.
	</p>
	<p>
		Finally, you can pipe that <code>int option</code> into Option.exists, which will evaluate to false if there's no value, or if the boolean expression <code>x &lt;= 3</code> evaluates to false.
	</p>
	<h3 id="1f26f442edc742b48a3c85a2832709b7">
		Input range <a href="#1f26f442edc742b48a3c85a2832709b7" title="permalink">#</a>
	</h3>
	<p>
		At this point, you're almost done. The only remaining properties you'll need to specify is that the maximum value is 3,999, and the minimum value is 1. Negative numbers, or zero, are not allowed:
	</p>
	<p>
		<pre>[&lt;<span style="color:#4ec9b0;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``negative&nbsp;numbers&nbsp;and&nbsp;zero&nbsp;are&nbsp;not&nbsp;supported``</span>&nbsp;i&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;i&nbsp;=&nbsp;-(<span style="color:navy;">abs</span>&nbsp;i)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">toRoman</span>&nbsp;i
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">test</span>&nbsp;<span style="background:yellow;">&lt;@&nbsp;</span><span style="color:#4ec9b0;background:yellow;">Option</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">isNone</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">actual</span><span style="background:yellow;">&nbsp;@&gt;</span></pre>
	</p>
	<p>
		In this property, the function argument <code>i</code> can be <em>any</em> number, but calling <code>abs</code> ensures that it's positive (or zero), and the unary <code>-</code> operator then converts that positive value to a negative value.
	</p>
	<p>
		Notice that the new <code>i</code> value shadows the input argument of the same name. This is <a href="/2016/02/15/types-properties-software-properties-for-the-forties">a common trick when writing properties</a>. It prevents me from accidentally using the input value provided by FsCheck. While the input argument is useful as a seed value, it isn't guaranteed to model the particular circumstances of this property. Here, you only care to assert what happens if the input is negative or zero. Specifically, you always want the return value to be None.
	</p>
	<p>
		Likewise for too large input values:
	</p>
	<p>
		<pre>[&lt;<span style="color:#4ec9b0;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)&gt;]
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">``numbers&nbsp;too&nbsp;big&nbsp;are&nbsp;not&nbsp;supported``</span>&nbsp;()&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">Gen</span>.<span style="color:navy;">choose</span>&nbsp;(4000,&nbsp;<span style="color:#4ec9b0;">Int32</span>.MaxValue)&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Arb</span>.<span style="color:navy;">fromGen</span>&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Prop</span>.<span style="color:navy;">forAll</span>&nbsp;&lt;|&nbsp;<span style="color:blue;">fun</span>&nbsp;i&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#4ec9b0;">Numeral</span>.<span style="color:navy;">toRoman</span>&nbsp;i
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">test</span>&nbsp;<span style="background:yellow;">&lt;@&nbsp;</span><span style="color:#4ec9b0;background:yellow;">Option</span><span style="background:yellow;">.</span><span style="color:navy;background:yellow;">isNone</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">actual</span><span style="background:yellow;">&nbsp;@&gt;</span></pre>
	</p>
	<p>
		Here, Gen.choose is used to define an Arbitrary&lt;int&gt; that only produces numbers between 4000 and Int32.MaxValue (including both boundary values).
	</p>
	<p>
		This test is similar to the one that exercises negative values, so you could combine them to a single function if you'd like. I'll leave this as an exercise, though.
	</p>
	<h3 id="28ffa8a5e8694aa7b0752175b5e2f2aa">
		Implementation <a href="#28ffa8a5e8694aa7b0752175b5e2f2aa" title="permalink">#</a>
	</h3>
	<p>
		The interesting part of this exercise is, I think, how to define the properties. There are many ways you can implement the functions to pass all properties. Here's one of them:
	</p>
	<p>
		<pre><span style="color:blue;">open</span>&nbsp;System
 
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">tryParseRoman</span>&nbsp;candidate&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">add</span>&nbsp;x&nbsp;=&nbsp;<span style="color:#4ec9b0;">Option</span>.<span style="color:navy;">map</span>&nbsp;((+)&nbsp;x)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:blue;">rec</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;acc&nbsp;=&nbsp;<span style="color:blue;">function</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;I&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;X&#39;</span><span style="color:navy;">::</span>xs&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;&nbsp;&nbsp;9)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;I&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;V&#39;</span><span style="color:navy;">::</span>xs&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;&nbsp;&nbsp;4)&nbsp;xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;I&#39;</span><span style="color:navy;">::</span>xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;&nbsp;&nbsp;1)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;V&#39;</span><span style="color:navy;">::</span>xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;&nbsp;&nbsp;5)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;X&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;C&#39;</span><span style="color:navy;">::</span>xs&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;&nbsp;90)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;X&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;L&#39;</span><span style="color:navy;">::</span>xs&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;&nbsp;40)&nbsp;xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;X&#39;</span><span style="color:navy;">::</span>xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;&nbsp;10)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;L&#39;</span><span style="color:navy;">::</span>xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;&nbsp;50)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;C&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;M&#39;</span><span style="color:navy;">::</span>xs&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;900)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;C&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;D&#39;</span><span style="color:navy;">::</span>xs&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;400)&nbsp;xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;C&#39;</span><span style="color:navy;">::</span>xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;100)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;D&#39;</span><span style="color:navy;">::</span>xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;&nbsp;500)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:#a31515;">&#39;M&#39;</span><span style="color:navy;">::</span>xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(acc&nbsp;|&gt;&nbsp;<span style="color:navy;">add</span>&nbsp;1000)&nbsp;xs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;acc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">None</span>
&nbsp;&nbsp;&nbsp;&nbsp;candidate&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">Seq</span>.<span style="color:navy;">toList</span>&nbsp;|&gt;&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:navy;">Some</span>&nbsp;0)
 
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">toRoman</span>&nbsp;i&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:blue;">rec</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;acc&nbsp;=&nbsp;<span style="color:blue;">function</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;1000&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;M&#39;</span><span style="color:navy;">::</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc)&nbsp;(x&nbsp;-&nbsp;1000)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;900&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;M&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;C&#39;</span><span style="color:navy;">::</span>acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;900)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;500&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;D&#39;</span><span style="color:navy;">::</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;500)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;400&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;D&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;C&#39;</span><span style="color:navy;">::</span>acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;400)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;100&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;C&#39;</span><span style="color:navy;">::</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;100)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;&nbsp;90&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;C&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;X&#39;</span><span style="color:navy;">::</span>acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;&nbsp;90)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;&nbsp;50&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;L&#39;</span><span style="color:navy;">::</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;&nbsp;50)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;&nbsp;40&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;L&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;X&#39;</span><span style="color:navy;">::</span>acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;&nbsp;40)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;&nbsp;10&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;X&#39;</span><span style="color:navy;">::</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;&nbsp;10)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;X&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;I&#39;</span><span style="color:navy;">::</span>acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;9)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;V&#39;</span><span style="color:navy;">::</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;5)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;V&#39;</span><span style="color:navy;">::</span><span style="color:#a31515;">&#39;I&#39;</span><span style="color:navy;">::</span>acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;4)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;<span style="color:blue;">when</span>&nbsp;x&nbsp;&gt;=&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;(<span style="color:#a31515;">&#39;I&#39;</span><span style="color:navy;">::</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc)&nbsp;(x&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;acc
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;0&nbsp;&lt;&nbsp;i&nbsp;&amp;&amp;&nbsp;i&nbsp;&lt;&nbsp;4000
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">then</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;[]&nbsp;i&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">List</span>.<span style="color:navy;">rev</span>&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">List</span>.<span style="color:navy;">toArray</span>&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">String</span>&nbsp;|&gt;&nbsp;<span style="color:navy;">Some</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;<span style="color:navy;">None</span></pre>
	</p>
	<p>
		Both functions use <a href="/2015/12/22/tail-recurse">tail-recursive inner <code>imp</code> functions</a> in order to accumulate the appropriate answer.
	</p>
	<p>
		One of the nice properties (that I didn't test for) of this implementation is that the tryParseRoman function is a <a href="http://martinfowler.com/bliki/TolerantReader.html">Tolerant Reader</a>. While toRoman would never create such a numeral, tryParseRoman correctly understands some alternative renderings:
	</p>
	<p>
		<pre>&gt; "MDCCCLXXXXIII" |&gt; tryParseRoman;;
val it : int option = Some 1893
&gt; 1893 |&gt; toRoman;;
val it : String option = Some "MDCCCXCIII"</pre>
	</p>
	<p>
		In other words, the implementation follows <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel's law</a>. tryParseRoman is liberal in what it accepts, while toRoman is conservative in what it returns.
	</p>
	<h3 id="0e7b6d96301e4d84a1a218b2caa7aca7">
		Summary <a href="#0e7b6d96301e4d84a1a218b2caa7aca7" title="permalink">#</a>
	</h3>
	<p>
		Some problems look, at first glance, as obvious candidates for example-driven development. In my experience, this particularly happen when obvious examples abound. It's not difficult to come up with examples of Roman numerals, so it seems intuitive that you should just start writing some test cases with various examples. In my experience, though, that doesn't guarantee that you're led towards a good implementation.
	</p>
	<p>
		The more a problem description is based on examples, the harder it can be to identify the underlying properties. Still, they're often there, once you start looking. As I've <a href="/2015/01/10/diamond-kata-with-fscheck">previously reported</a>, using property-based test-driven development enables you to proceed in a more incremental fashion, because properties describe only parts of the desired solution.
	</p>
	<p>
		If you're interested in learning more about Property-Based Testing, you can watch my <a href="{{ site.production_url }}/property-based-testing-intro">introduction to Property-based Testing with F#</a> Pluralsight course.
	</p>
</div>