---
layout: post
title: "Make pre-conditions explicit in Property-Based Tests"
description: "Pre-conditions are important in Property-Based Tests."
date: 2016-01-18 12:00 UTC
tags: [Unit Testing, F#, FsCheck, Property-based Testing]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		Last week, I was giving a workshop on Property-Based Testing, and we were looking at this test:
	</p>
	<p>
		<pre>[&lt;Property&gt;]
<span style="color:blue;">let</span>&nbsp;``Validate.reservation&nbsp;returns&nbsp;right&nbsp;result&nbsp;on&nbsp;invalid&nbsp;date``
&nbsp;&nbsp;&nbsp;&nbsp;(rendition&nbsp;:&nbsp;ReservationRendition)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;Validate.reservation&nbsp;rendition
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;expected&nbsp;:&nbsp;Result&lt;Reservation,&nbsp;Error&gt;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Failure(ValidationError(<span style="color:#a31515;">&quot;Invalid&nbsp;date.&quot;</span>))
&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;<span style="background:yellow;">&lt;@&nbsp;</span><span style="background:yellow;">expected</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">=</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">actual</span><span style="background:yellow;">&nbsp;@&gt;</span></pre>
	</p>
	<p>
		The test case being exercised by this test is to verify what happens when the input (essentially a representation of an incoming JSON document) is invalid.
	</p>
	<p>
		The System Under Test is this function:
	</p>
	<p>
		<pre><span style="color:blue;">module</span>&nbsp;<span style="color:#4ec9b0;">Validate</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">reservation</span>&nbsp;(rendition&nbsp;:&nbsp;<span style="color:#4ec9b0;">ReservationRendition</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">match</span>&nbsp;rendition.Date&nbsp;|&gt;&nbsp;<span style="color:#4ec9b0;">DateTimeOffset</span>.<span style="color:navy;">TryParse</span>&nbsp;<span style="color:blue;">with</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(<span style="color:blue;">true</span>,&nbsp;date)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">Success</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;=&nbsp;date
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;rendition.Name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Email&nbsp;=&nbsp;rendition.Email
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantity&nbsp;=&nbsp;rendition.Quantity&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">Failure</span>(<span style="color:navy;">ValidationError</span>&nbsp;<span style="color:#a31515;">&quot;Invalid&nbsp;date.&quot;</span>)</pre>
	</p>
	<p>
		The validation rule is simple: if the rendition.Date string can be parsed into a DateTimeOffset value, then the input is valid; otherwise, it's not.
	</p>
	<p>
		If you run the test, if passes:
	</p>
	<p>
		<pre>Output from Ploeh.Samples.BookingApi.UnitTests.ValidatorTests.Validate.reservation returns right result on invalid date:
  Ok, passed 100 tests.</pre>
	</p>
	<p>
		Only, this test isn't <em>guaranteed</em> to pass. Can you spot the problem?
	</p>
	<p>
		There's a tiny, but real, risk that the randomly generated rendition.Date string <em>can</em> be parsed as a DateTimeOffset value. While it's not particularly likely, it will happen once in a blue moon. This can lead to spurious <a href="http://xunitpatterns.com/false%20positive.html">false positives</a>.
	</p>
	<p>
		In order to see this, you can increase the number of test cases generated by FsCheck:
	</p>
	<p>
		<pre>[&lt;Property(MaxTest&nbsp;=&nbsp;100000)&gt;]
<span style="color:blue;">let</span>&nbsp;``Validate.reservation&nbsp;returns&nbsp;right&nbsp;result&nbsp;on&nbsp;invalid&nbsp;date``
&nbsp;&nbsp;&nbsp;&nbsp;(rendition&nbsp;:&nbsp;ReservationRendition)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;Validate.reservation&nbsp;rendition
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;expected&nbsp;:&nbsp;Result&lt;Reservation,&nbsp;Error&gt;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Failure(ValidationError(<span style="color:#a31515;">&quot;Invalid&nbsp;date.&quot;</span>))
&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;<span style="background:yellow;">&lt;@&nbsp;</span><span style="background:yellow;">expected</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">=</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">actual</span><span style="background:yellow;">&nbsp;@&gt;</span></pre>
	</p>
	<p>
		In my experience, when you ask for 100,000 test cases, the property usually fails:
	</p>
	<p>
		<pre>Test 'Ploeh.Samples.BookingApi.UnitTests.ValidatorTests.Validate.reservation returns right result on invalid date' failed:
	FsCheck.Xunit.PropertyFailedException : 
Falsifiable, after 9719 tests (11 shrinks) (StdGen (1054829489,296106988)):
Original:
{Date = "7am";
 Name = "6WUx;";
 Email = "W";
 Quantity = -5;}
Shrunk:
{Date = "7am";
 Name = "";
 Email = "";
 Quantity = 0;}

---- Swensen.Unquote.AssertionFailedException : Test failed:

Failure (ValidationError "Invalid date.") = Success {Date = 15.01.2016 07:00:00 +00:00;
         Name = "";
         Email = "";
         Quantity = 0;}
false</pre>
	</p>
	<p>
		The problem is that the generated date "7am" <em>can</em> be parsed as a DateTimeOffset value:
	</p>
	<p>
		<pre>&gt; open System;;
&gt; DateTimeOffset.Now;;
val it : DateTimeOffset =
  15.01.2016 21:09:25 +00:00
&gt; "7am" |&gt; DateTimeOffset.TryParse;;
val it : bool * DateTimeOffset =
  (true, 15.01.2016 07:00:00 +00:00)</pre>
	</p>
	<p>
		The above test is written with the implicit assumption that the generated value for rendition.Date will always be an invalidly formatted string. As <a href="https://www.python.org/dev/peps/pep-0020">the Zen of Python</a> reminds us, <em>explicit is better than implicit</em>. You should make that assumption explicit:
	</p>
	<p>
		<pre>[&lt;Property&gt;]
<span style="color:blue;">let</span>&nbsp;``Validate.reservation&nbsp;returns&nbsp;right&nbsp;result&nbsp;on&nbsp;invalid&nbsp;date``
&nbsp;&nbsp;&nbsp;&nbsp;(rendition&nbsp;:&nbsp;ReservationRendition)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;not(fst(DateTimeOffset.TryParse&nbsp;rendition.Date))&nbsp;==&gt;&nbsp;<span style="color:blue;">lazy</span>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;Validate.reservation&nbsp;rendition
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;expected&nbsp;:&nbsp;Result&lt;Reservation,&nbsp;Error&gt;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Failure(ValidationError(<span style="color:#a31515;">&quot;Invalid&nbsp;date.&quot;</span>))
&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;<span style="background:yellow;">&lt;@&nbsp;</span><span style="background:yellow;">expected</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">=</span><span style="background:yellow;">&nbsp;</span><span style="background:yellow;">actual</span><span style="background:yellow;">&nbsp;@&gt;</span></pre>
	</p>
	<p>
		This version of the test uses FsCheck's built-in custom operator <code>==&gt;</code>. This operator will only evaluate the expression on the right-hand side if the boolean expression on the left-hand side evaluates to <code>true</code>. In the unlikely event that the above condition evaluates to <code>false</code>, FsCheck is going to ignore that randomly generated value, and try with a new one.
	</p>
	<p>
		This version of the test succeeds, even if you set MaxTest to 1,000,000.
	</p>
	<p>
		The <code>==&gt;</code> operator effectively discards candidate values that don't match the 'guard' condition. You shouldn't always use this feature to constrain the input, as it can be wasteful. If the condition isn't satisfied, FsCheck will attempt to generate a new value that satisfies the condition. In this particular example, only in extremely rare cases will FsCheck be forced to discard a candidate value, so this use of the feature is appropriate.
	</p>
	<p>
		In other cases, you should consider other options. Imagine that you want only even numbers. While you could write a 'guard' condition that ensures that only even numbers are used, that would cause FsCheck to throw away half of the generated candidates. In such cases, you should instead consider defining a custom Arbitrary, using FsCheck's API.
	</p>
	<p>
		Another discussion entirely is whether the current behaviour is a good idea. If we consider tests as a feedback mechanism about software design, then perhaps we should explicitly specify the expected format. At the moment, the implementation is an extremely <a href="http://martinfowler.com/bliki/TolerantReader.html">Tolerant Reader</a> (because DateTimeOffset.TryParse is a Tolerant Reader). Perhaps it'd make sense to instead use <a href="https://msdn.microsoft.com/en-us/library/system.datetimeoffset.tryparseexact">TryParseExact</a>. That's an API modelling decision, though, and might have to involve various other stakeholders than only programmers.
	</p>
	<p>
		If you wish to learn more about Property-Based Testing with FsCheck, consider watching <a href="{{ site.production_url }}/property-based-testing-intro">my Pluralsight course</a>.
	</p>
</div>