---
layout: post
title: "A Visitor functor"
description: "Some Visitors can be functors. Another functor example for object-oriented programmers."
date: 2018-08-13 6:56 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		This article is an instalment in <a href="/2018/03/22/functors">an article series about functors</a>. In the <a href="/2018/08/06/a-tree-functor">previous article</a>, you saw how to implement a generalised tree as a functor. In this article, you'll see another functor example, which will also be an application of the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor design pattern</a>.
	</p>
	<p>
		The Visitor design pattern is often described in such a way that it's based on mutation; the <code>Visit</code> and <code>Accept</code> methods in those descriptions typically return <code>void</code>. You can, however, also implement immutable variations. This blog already contains <a href="/2011/05/16/TennisKatawithimmutabletypesandacyclomaticcomplexityof1">an older example of this</a>.
	</p>
	<h3 id="e58c06335ed34b45a31024e88464c23f">
		Visitor <a href="#e58c06335ed34b45a31024e88464c23f" title="permalink">#</a>
	</h3>
	<p>
		In this article, you'll see how to implement a full binary tree using the Visitor design pattern. You can make the tree generic, so that each node can contain values of any generic type.
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">TResult</span>&nbsp;Accept&lt;<span style="color:#2b91af;">TResult</span>&gt;(<span style="color:#2b91af;">IBinaryTreeVisitor</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;visitor);
}</pre>
	</p>
	<p>
		As promised, this interface implies an immutable variant where the <code>Accept</code> method doesn't mutate the input Visitor, but rather returns a new value. You can learn how you arrive at this particular generic method signature in my article <a href="/2018/06/25/visitor-as-a-sum-type">Visitor as a sum type</a>.
	</p>
	<p>
		A full binary tree is a tree where each node has either zero or two children. This means that a Visitor must have two methods, one for each case:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IBinaryTreeVisitor</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">TResult</span>&nbsp;Visit(<span style="color:#2b91af;">Node</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;node);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">TResult</span>&nbsp;Visit(<span style="color:#2b91af;">Leaf</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;leaf);
}</pre>
	</p>
	<p>
		The <code>IBinaryTreeVisitor&lt;T, TResult&gt;</code> interface introduces two new concrete classes: <code>Node&lt;T&gt;</code> and <code>Leaf&lt;T&gt;</code>. A leaf node is a node with zero children:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">sealed</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Leaf</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;:&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">T</span>&nbsp;Item&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Leaf(<span style="color:#2b91af;">T</span>&nbsp;item)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(item&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(item));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;=&nbsp;item;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">TResult</span>&nbsp;Accept&lt;<span style="color:#2b91af;">TResult</span>&gt;(<span style="color:#2b91af;">IBinaryTreeVisitor</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;visitor)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(visitor&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(visitor));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;visitor.Visit(<span style="color:blue;">this</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;Equals(<span style="color:blue;">object</span>&nbsp;obj)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(!(obj&nbsp;<span style="color:blue;">is</span>&nbsp;<span style="color:#2b91af;">Leaf</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;other))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Equals(Item,&nbsp;other.Item);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">int</span>&nbsp;GetHashCode()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Item.GetHashCode();
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		While a leaf node has no children, it still contains an <code>Item</code> of the generic type <code>T</code>. A leaf node still counts as a binary tree, so it implements the <code>IBinaryTree&lt;T&gt;</code> interface. Complying with the Visitor design pattern, its <code>Accept</code> method is implemented using double dispatch. Thereby, any <code>visitor</code> knows that it's now visiting a concrete <code>Leaf&lt;T&gt;</code> object.
	</p>
	<p>
		Likewise, a node is a (sub)tree:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">sealed</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Node</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;:&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">T</span>&nbsp;Item&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;Left&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;Right&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Node(<span style="color:#2b91af;">T</span>&nbsp;item,&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;left,&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;right)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(item&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(item));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(left&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(left));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(right&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(right));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;=&nbsp;item;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;=&nbsp;left;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;=&nbsp;right;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">TResult</span>&nbsp;Accept&lt;<span style="color:#2b91af;">TResult</span>&gt;(<span style="color:#2b91af;">IBinaryTreeVisitor</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;visitor)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(visitor&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(visitor));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;visitor.Visit(<span style="color:blue;">this</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;Equals(<span style="color:blue;">object</span>&nbsp;obj)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(!(obj&nbsp;<span style="color:blue;">is</span>&nbsp;<span style="color:#2b91af;">Node</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;other))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">false</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Equals(Item,&nbsp;other.Item)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;Equals(Left,&nbsp;other.Left)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;Equals(Right,&nbsp;other.Right);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">int</span>&nbsp;GetHashCode()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Item.GetHashCode()&nbsp;^&nbsp;Left.GetHashCode()&nbsp;^&nbsp;Right.GetHashCode();
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		In addition to an <code>Item</code>, a <code>Node&lt;T&gt;</code> object also contains a <code>Left</code> and a <code>Right</code> sub-tree. Notice that the <code>Accept</code> method is literally identical to <code>Leaf&lt;T&gt;.Accept</code>. Its behaviour differs, though, because <code>this</code> has a different type.
	</p>
	<p>
		A couple of static helper methods makes it a bit easier to create binary tree objects:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">BinaryTree</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;Leaf&lt;<span style="color:#2b91af;">T</span>&gt;(<span style="color:#2b91af;">T</span>&nbsp;item)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Leaf</span>&lt;<span style="color:#2b91af;">T</span>&gt;(item);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;Create&lt;<span style="color:#2b91af;">T</span>&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">T</span>&nbsp;item,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;right)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Node</span>&lt;<span style="color:#2b91af;">T</span>&gt;(item,&nbsp;left,&nbsp;right);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		The main convenience of these two methods is that C# (limited) type inference enables you to create tree objects without explicitly typing out the generic type argument every time. You'll soon see an example of creating a binary tree of integers.
	</p>
	<h3 id="75e8ba18e47049a6809896e0189fe0d9">
		Functor <a href="#75e8ba18e47049a6809896e0189fe0d9" title="permalink">#</a>
	</h3>
	<p>
		Since <code>IBinaryTree&lt;T&gt;</code> is a generic type, you should consider whether it's a functor. Given the overall topic of this article, you'd hardly be surprised that it is.
	</p>
	<p>
		In the previous two functor examples (<a href="/2018/03/26/the-maybe-functor">Maybe</a> and <a href="/2018/08/06/a-tree-functor">Tree</a>), the <code>Select</code> methods were instance methods. On the other hand, the .NET Base Class Library implements <code>IEnumerable&lt;T&gt;.Select</code> as an extension method. You can do the same with this binary tree Visitor:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;Select&lt;<span style="color:#2b91af;">TResult</span>,&nbsp;<span style="color:#2b91af;">T</span>&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;tree,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;selector)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(tree&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(tree));
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(selector&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(selector));
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;visitor&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">SelectBinaryTreeVisitor</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;(selector);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;tree.Accept(visitor);
}</pre>
	</p>
	<p>
		This <code>Select</code> method has the right signature for turning <code>IBinaryTree&lt;T&gt;</code> into a functor. It starts by creating a new instance of a private helper class called <code>SelectBinaryTreeVisitor&lt;T, TResult&gt;</code>. Notice that this class has two generic type arguments: the source type <code>T</code> and the destination type <code>TResult</code>. It also contains <code>selector</code>, so that it knows what to do with each <code>Item</code> it encounters.
	</p>
	<p>
		<code>SelectBinaryTreeVisitor&lt;T, TResult&gt;</code> is a Visitor, so you pass it to the <code>tree</code> object's <code>Accept</code> method. The <code>Accept</code> method returns a variable that you can directly return, because, as you'll see below, the return type of <code>SelectBinaryTreeVisitor&lt;T, TResult&gt;</code>'s <code>Visit</code> methods is <code>IBinaryTree&lt;TResult&gt;</code>.
	</p>
	<p>
		<code>SelectBinaryTreeVisitor&lt;T, TResult&gt;</code> is a <code>private</code> helper class, and is the most complex functor implementation you've seen so far. The Visitor design pattern solves a specific problem, but it was never the simplest of design patterns.
	</p>
	<p>
		<pre><span style="color:blue;">private</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">SelectBinaryTreeVisitor</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IBinaryTreeVisitor</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;selector;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;SelectBinaryTreeVisitor(<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;selector)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(selector&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(selector));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.selector&nbsp;=&nbsp;selector;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;Visit(<span style="color:#2b91af;">Leaf</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;leaf)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;mappedItem&nbsp;=&nbsp;selector(leaf.Item);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Leaf(mappedItem);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;Visit(<span style="color:#2b91af;">Node</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;node)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;mappedItem&nbsp;=&nbsp;selector(node.Item);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;mappedLeft&nbsp;=&nbsp;node.Left.Accept(<span style="color:blue;">this</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;mappedRight&nbsp;=&nbsp;node.Right.Accept(<span style="color:blue;">this</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Create(mappedItem,&nbsp;mappedLeft,&nbsp;mappedRight);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		Since the class implements <code>IBinaryTreeVisitor&lt;T,&nbsp;IBinaryTree&lt;TResult&gt;&gt;</code>, it must implement the two <code>Visit</code> overloads. The overload for <code>Leaf&lt;T&gt;</code> is simple: use the <code>selector</code> to map the <code>Item</code>, and use the <code>Leaf</code> convenience method to return a new <code>Leaf&lt;TResult&gt;</code> containing the mapped item. Notice that while <code>SelectBinaryTreeVisitor&lt;T, TResult&gt;</code> looks like it has a generic 'return' type argument of <code>TResult</code>, it implements <code>IBinaryTreeVisitor&lt;T,&nbsp;IBinaryTree&lt;TResult&gt;&gt;</code>, which means that the return type of each <code>Visit</code> method must be <code>IBinaryTree&lt;TResult&gt;</code>, and that matches <code>Leaf&lt;TResult&gt;</code>.
	</p>
	<p>
		The overload for a <code>Node&lt;T&gt;</code> object looks twice as big, but it's still simple. Like the leaf overload, it uses <code>selector</code> to map the <code>Item</code>, but in addition to that, it must also recursively map the <code>Left</code> and <code>Right</code> sub-trees. It does this by passing itself, in its role as a Visitor, to the left and right nodes' <code>Accept</code> methods. This returns mapped sub-trees that can be used to create a new mapped tree, using the <code>Create</code> convenience method.
	</p>
	<h3 id="05044a8452844974980483246078f0e2">
		Usage <a href="#05044a8452844974980483246078f0e2" title="permalink">#</a>
	</h3>
	<p>
		While the implementation of such a Visitor is cumbersome, it's easy enough to use.
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;source&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(42,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(1337,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(-22)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(100));</pre>
	</p>
	<p>
		You can translate this binary tree of integers to a tree of strings using method call syntax:
	</p>
	<p>
		<pre><span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:blue;">string</span>&gt;&nbsp;dest&nbsp;=&nbsp;source.Select(i&nbsp;=&gt;&nbsp;i.ToString());
</pre>
	</p>
	<p>
		or by using query syntax:
	</p>
	<p>
		<pre><span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:blue;">string</span>&gt;&nbsp;dest&nbsp;=&nbsp;<span style="color:blue;">from</span>&nbsp;i&nbsp;<span style="color:blue;">in</span>&nbsp;source
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">select</span>&nbsp;i.ToString();</pre>		
	</p>
	<p>
		In both of these examples, I've explicitly declared the type of <code>dest</code> instead of using the <code>var</code> keyword. There's no practical reason to do this; I only did it to make the type clear to you.
	</p>
	<h3 id="6db319918e384c2e82c64aba8e24d73c">
		Haskell <a href="#6db319918e384c2e82c64aba8e24d73c" title="permalink">#</a>
	</h3>
	<p>
		Why would anyone ever do something so complicated as this?
	</p>
	<p>
		The answer to such a question is, I believe, that it's only complicated in <em>some</em> programming languages. In <a href="https://haskell.org">Haskell</a>, <em>all</em> of the above can be reduce to <em>a single</em> type declaration:
	</p>
	<p>
		<pre><span style="color:blue;">data</span>&nbsp;<span style="color:#dd0000;">BinaryTree</span>&nbsp;a&nbsp;<span style="color:#666666;">=</span>&nbsp;<span style="color:#dd0000;">Node</span>&nbsp;a&nbsp;(<span style="color:#dd0000;">BinaryTree</span>&nbsp;a)&nbsp;(<span style="color:#dd0000;">BinaryTree</span>&nbsp;a)&nbsp;<span style="color:#666666;">|</span>&nbsp;<span style="color:#dd0000;">Leaf</span>&nbsp;a
&nbsp;&nbsp;<span style="color:blue;">deriving</span>&nbsp;(<span style="color:#a31515;">Show</span>,&nbsp;<span style="color:#a31515;">Eq</span>,&nbsp;<span style="color:#a31515;">Functor</span>)</pre>
	</p>
	<p>
		Notice that the Haskell compiler can automatically derive an implementation of the <code>Functor</code> typeclass, although that does require the <code>DeriveFunctor</code> language extension.
	</p>
	<p>
		This may explain why binary trees aren't part of object-oriented programmers' normal tool box, whereas they are more commonplace in functional programming.
	</p>
	<p>
		While not strictly required, in order to keep the examples equivalent, you can define these two aliases:
	</p>
	<p>
		<pre><span style="color:#600277;">leaf</span>&nbsp;::&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">BinaryTree</span>&nbsp;a
leaf&nbsp;<span style="color:#666666;">=</span>&nbsp;<span style="color:#dd0000;">Leaf</span>
 
<span style="color:#600277;">create</span>&nbsp;::&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">BinaryTree</span>&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">BinaryTree</span>&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">BinaryTree</span>&nbsp;a
create&nbsp;<span style="color:#666666;">=</span>&nbsp;<span style="color:#dd0000;">Node</span></pre>
	</p>
	<p>
		This enables you to create a binary tree like this:
	</p>
	<p>
		<pre><span style="color:#600277;">source</span>&nbsp;::&nbsp;<span style="color:blue;">BinaryTree</span>&nbsp;Int
source&nbsp;<span style="color:#666666;">=</span>
&nbsp;&nbsp;&nbsp;&nbsp;create&nbsp;<span style="color:#09885a;">42</span>&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create&nbsp;<span style="color:#09885a;">1337</span>&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leaf&nbsp;<span style="color:#09885a;">0</span>)&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leaf&nbsp;(<span style="color:#666666;">-</span><span style="color:#09885a;">22</span>)))&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leaf&nbsp;<span style="color:#09885a;">100</span>)</pre>
	</p>
	<p>
		As usual you can map the tree using the <code>fmap</code> function:
	</p>
	<p>
		<pre><span style="color:#600277;">dest</span>&nbsp;::&nbsp;<span style="color:blue;">BinaryTree</span>&nbsp;String
dest&nbsp;<span style="color:#666666;">=</span>&nbsp;fmap&nbsp;show&nbsp;source</pre>
	</p>
	<p>
		or by using infix notation:
	</p>
	<p>
		<pre><span style="color:#600277;">dest</span>&nbsp;::&nbsp;<span style="color:blue;">BinaryTree</span>&nbsp;String
dest&nbsp;<span style="color:#666666;">=</span>&nbsp;show&nbsp;<span style="color:#666666;">&lt;$&gt;</span>&nbsp;source</pre>
	</p>
	<p>
		The <code>&lt;$&gt;</code> operator is an alias for <code>fmap</code>.
	</p>
	<h3 id="a0698e17ebc5402a9ce2b9e93dcf581a">
		F# <a href="#a0698e17ebc5402a9ce2b9e93dcf581a" title="permalink">#</a>
	</h3>
	<p>
		As usual, <a href="https://fsharp.org">F#</a> lies somewhere between the extremes of C# and Haskell, although it's closer to Haskell in simplicity. The type declaration is similar:
	</p>
	<p>
		<pre><span style="color:blue;">type</span>&nbsp;<span style="color:teal;">BinaryTree</span>&lt;&#39;a&gt;&nbsp;=
|&nbsp;<span style="color:navy;">Node</span>&nbsp;<span style="color:blue;">of</span>&nbsp;(&#39;a&nbsp;*&nbsp;<span style="color:teal;">BinaryTree</span>&lt;&#39;a&gt;&nbsp;*&nbsp;<span style="color:teal;">BinaryTree</span>&lt;&#39;a&gt;)
|&nbsp;<span style="color:navy;">Leaf</span>&nbsp;<span style="color:blue;">of</span>&nbsp;&#39;a</pre>
	</p>
	<p>
		Unlike Haskell, however, F# doesn't have any built-in functor awareness, so you'll have to implement the <em>map</em> function yourself:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;(&#39;a&nbsp;-&gt;&nbsp;&#39;b)&nbsp;-&gt;&nbsp;BinaryTree&lt;&#39;a&gt;&nbsp;-&gt;&nbsp;BinaryTree&lt;&#39;b&gt;</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:blue;">rec</span>&nbsp;<span style="color:navy;">map</span>&nbsp;<span style="color:navy;">f</span>&nbsp;=&nbsp;<span style="color:blue;">function</span>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:navy;">Node</span>&nbsp;(x,&nbsp;left,&nbsp;right)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">Node</span>&nbsp;(<span style="color:navy;">f</span>&nbsp;x,&nbsp;<span style="color:navy;">map</span>&nbsp;<span style="color:navy;">f</span>&nbsp;left,&nbsp;<span style="color:navy;">map</span>&nbsp;<span style="color:navy;">f</span>&nbsp;right)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span style="color:navy;">Leaf</span>&nbsp;x&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">Leaf</span>&nbsp;(<span style="color:navy;">f</span>&nbsp;x)</pre>
	</p>
	<p>
		Notice that you have to use the <code>rec</code> keyword in order to make <code>map</code> recursive. Instead of having to create a new helper class, and all the byzantine interactions required by the Visitor design pattern, the implementation uses simple pattern matching to achieve the same goal. In the <code>Node</code> case, it uses <code>f</code> to translate <code>x</code>, and recursively calls itself on <code>left</code> and <code>right</code>. In the <code>Leaf</code> case, it simply returns a new <code>Leaf</code> value with <code>x</code> translated by <code>f</code>.
	</p>
	<p>
		Create helper functions to keep all three examples aligned:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;&#39;a&nbsp;-&gt;&nbsp;BinaryTree&lt;&#39;a&gt;</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">leaf</span>&nbsp;=&nbsp;<span style="color:navy;">Leaf</span>
 
<span style="color:green;">//&nbsp;&#39;a&nbsp;-&gt;&nbsp;BinaryTree&lt;&#39;a&gt;&nbsp;-&gt;&nbsp;BinaryTree&lt;&#39;a&gt;&nbsp;-&gt;&nbsp;BinaryTree&lt;&#39;a&gt;</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">create</span>&nbsp;x&nbsp;left&nbsp;right&nbsp;=&nbsp;<span style="color:navy;">Node</span>&nbsp;(x,&nbsp;left,&nbsp;right)</pre>
	</p>
	<p>
		You can now create a binary tree of integers:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;BinaryTree&lt;int&gt;</span>
<span style="color:blue;">let</span>&nbsp;source&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:teal;">BinaryTree</span>.<span style="color:navy;">create</span>&nbsp;42&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:teal;">BinaryTree</span>.<span style="color:navy;">create</span>&nbsp;1337&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:teal;">BinaryTree</span>.<span style="color:navy;">leaf</span>&nbsp;0)&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:teal;">BinaryTree</span>.<span style="color:navy;">leaf</span>&nbsp;-22))&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:teal;">BinaryTree</span>.<span style="color:navy;">leaf</span>&nbsp;100)</pre>
	</p>
	<p>
		which you can translate like this:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;BinaryTree&lt;string&gt;</span>
<span style="color:blue;">let</span>&nbsp;dest&nbsp;=&nbsp;source&nbsp;|&gt;&nbsp;<span style="color:teal;">BinaryTree</span>.<span style="color:navy;">map</span>&nbsp;<span style="color:navy;">string</span></pre>
	</p>
	<p>
		Here, all of the above functions are defined in a module named <code>BinaryTree</code>.
	</p>
	<h3 id="cd79db20d2e24587be91ade6ae956b0e">
		First functor law <a href="#cd79db20d2e24587be91ade6ae956b0e" title="permalink">#</a>
	</h3>
	<p>
		The <code>Select</code> method obeys the first functor law. As usual, it's proper computer-science work to actually prove that, but you can write some tests to demonstrate the first functor law for the <code>IBinaryTree&lt;T&gt;</code> interface. In this article, you'll see a few parametrised tests written with <a href="https://xunit.net">xUnit.net</a>. First, you can define some reusable trees as test input:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">object</span>[]&gt;&nbsp;Trees
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">get</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">yield</span>&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(0)&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">yield</span>&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>[]&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(-3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(99))&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">yield</span>&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>[]&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(42,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(1337,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(-22)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(100))&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">yield</span>&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>[]&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(-927,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(211,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(88),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(132)))&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">yield</span>&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>[]&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(111,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(-336,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(113),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(-432)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Create(1299,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(-32),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">BinaryTree</span>.Leaf(773)))&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		This is just a collection of five small binary trees that can be used as input for parametrised tests. The first tree is only a single node - the simplest tree you can make with the <code>IBinaryTree&lt;T&gt;</code> API.
	</p>
	<p>
		You can use this static property as a source of input for parametrised tests. Here's one that demonstrates that the first functor law holds:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>,&nbsp;<span style="color:#2b91af;">MemberData</span>(<span style="color:blue;">nameof</span>(Trees))]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;FirstFunctorLaw(<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;tree)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.Equal(tree,&nbsp;tree.Select(x&nbsp;=&gt;&nbsp;x));
}</pre>
	</p>
	<p>
		Here, I chose to implement the identity function as an anonymous lambda expression. In contrast, in a <a href="/2018/03/26/the-maybe-functor">previous article</a>, I explicitly declared a function variable and called it <code>id</code>. Those two ways to express the identity function are equivalent.
	</p>
	<p>
		As always, I'd like to emphasise that this test doesn't <em>prove</em> that <code>IBinaryTree&lt;T&gt;</code> obeys the first functor law. It only demonstrates that the law holds for those five examples.
	</p>
	<h3 id="f68059de38e24d0b9745b7e8071354d1">
		Second functor law <a href="#f68059de38e24d0b9745b7e8071354d1" title="permalink">#</a>
	</h3>
	<p>
		Like the above example, you can also write a parametrised test that demonstrates that <code>IBinaryTree&lt;T&gt;</code> obeys the second functor law. You can reuse the <code>Trees</code> test case source for that test:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Theory</span>,&nbsp;<span style="color:#2b91af;">MemberData</span>(<span style="color:blue;">nameof</span>(Trees))]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;SecondFunctorLaw(<span style="color:#2b91af;">IBinaryTree</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;tree)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;g(<span style="color:blue;">int</span>&nbsp;i)&nbsp;=&gt;&nbsp;i.ToString();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">bool</span>&nbsp;f(<span style="color:blue;">string</span>&nbsp;s)&nbsp;=&gt;&nbsp;s.Length&nbsp;%&nbsp;2&nbsp;==&nbsp;0;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.Equal(tree.Select(g).Select(f),&nbsp;tree.Select(i&nbsp;=&gt;&nbsp;f(g(i))));
}</pre>
	</p>
	<p>
		This test defines two local functions, <code>f</code> and <code>g</code>. Instead of explicitly declaring the functions as <code>Func</code> variables, this test uses a (relatively) new C# feature called <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions">local functions</a>.
	</p>
	<p>
		Again, while the test doesn't prove anything, it demonstrates that for the five test cases, it doesn't matter if you project the <code>tree</code> in one or two steps.
	</p>
	<h3 id="cb5749ec27474647b6d96679c5d1d0ce">
		Summary <a href="#cb5749ec27474647b6d96679c5d1d0ce" title="permalink">#</a>
	</h3>
	<p>
		Statically typed functional languages like F# and Haskell enable you to define <a href="https://en.wikipedia.org/wiki/Tagged_union">sum types</a>: types that encode a selection of mutually exclusive cases. Combined with pattern matching, it's easy to deal with values that can be one of several non-polymorphic cases. Object-oriented languages like C# or Java don't have good support for this type of data structure. Object-oriented programmers often resort to using type hierarchies, but this requires down-casting in order to work. It also comes with the disadvantage that with type hierarchies, the hierarchy is extensible, which means that as an implementer, you never know if you've handled all sub-types. <a href="/2018/06/25/visitor-as-a-sum-type">The Visitor design pattern is a way to model sum types in object-oriented programming</a>, although it tends to be verbose.
	</p>
	<p>
		Nevertheless, if you have a generic type that models a set of mutually exclusive cases, it just may be a functor. In Haskell, you can make such a type a <code>Functor</code> with a mere declaration. In C#, you have to write considerable amounts of code.
	</p>
	<p>
		<strong>Next:</strong> <a href="/2018/08/20/reactive-functor">Reactive functor</a>.
	</p>
</div>