---
layout: post
title: "REST lesson learned: Avoid hackable URLs"
description: "Avoid hackable URLs if you are building a REST API."
date: 2013-05-01 10:29 UTC
tags: [Software Design, Services, REST]
image: "/content/binary/great-divide-between-richardson-level-2-and-3.png"
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		This is a <a href="/2013/04/29/rest-lessons-learned">lesson about REST API design that I learned while building non-trivial REST APIs</a>. If you provide a full-on <a href="http://martinfowler.com/articles/richardsonMaturityModel.html">level 3</a> REST API, consider avoiding hackable URLs.
	</p>
	<h3 id="690f964e718a42f0b0745c0b2f7152bc">
		Hackable URLs <a href="#690f964e718a42f0b0745c0b2f7152bc" title="permalink">#</a>
	</h3>
	<p>
		A <em>hackable URL</em> is a URL where there's a clear pattern or template for constructing the URL. As an example, if I present to you the URL <code>http://foo.ploeh.dk/products/1234</code>, it's easy to guess that this is a resource representing a product with the SKU of <em>1234</em>. If you know the SKU of another product, it's easy to 'hack' the URL to produce e.g. <code>http://foo.ploeh.dk/products/5678</code>.
	</p>
	<p>
		That's a really nice feature of your API if you are doing a <a href="http://martinfowler.com/articles/richardsonMaturityModel.html">level 1 or 2</a> API, but for a <a href="http://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a> API, this defies the purpose.
	</p>
	<h3 id="29f09d92de5742608a2977cc4c3d6516">
		The great divide <a href="#29f09d92de5742608a2977cc4c3d6516" title="permalink">#</a>
	</h3>
	<p>
		Please notice that the shift from level 2 to level 3 RESTful APIs mark a fundamental shift in the way you should approach URL design.
	</p>
	<p>
		<img src="/content/binary/great-divide-between-richardson-level-2-and-3.png">
	</p>
	<p>
		Hackable URLs are great for level 1 and 2 APIs because the way you (as a client) are told to construct URLs is by assembling them from templates. As <a href="http://msdn.microsoft.com/en-us/library/windowsazure/dd179370.aspx">an example</a>, the Windows Azure REST APIs explicitly instruct you to construct the URL in a particular way: the URL to get BLOB container properties is <code>https://myaccount.blob.core.windows.net/mycontainer?restype=container</code>, where you should replace <em>myaccount</em> with your account name, and <em>mycontainer</em> with your container name. While code aesthetics are subjective, it's not even a particularly <a href="http://en.wikipedia.org/wiki/Clean_URL">clean URL</a>, but it's easy enough to produce. The URL template is part of the contract, which puts the Windows Azure API solidly at level 2 of the Richardson Maturity Model. If I were designing a level 1 or 2 API, I'd make sure to make URLs hackable, too.
	</p>
	<p>
		However, if you're building a level 3 API, hypermedia is king. Clients are expected to <em>follow links</em>. The addresses of resources are <em>not</em> published as having a particular template; instead, clients must follow semantic links in order to arrive at the desired resource(s). When hypermedia is the engine of application state, it's no good if the client can short-circuit the application flow by 'hacking' URLs. It may leave the application in an inconsistent state if it tries to do that.
	</p>
	<p>
		Hackable URLs are great for level 1 and 2 APIs, but counter-productive for level 3 APIs.
	</p>
	<h3 id="3a57655306344306b3c1ac5a001a505d">
		Evolving URLs <a href="#3a57655306344306b3c1ac5a001a505d" title="permalink">#</a>
	</h3>
	<p>
		One of the main attractions of building a level 3 RESTful API is that it's easier to evolve. Exactly because URL templates are <em>not</em> part of the contract, you can decide to change the URL structure when evolving your API.
	</p>
	<p>
		Imagine that the first version of your API has an (internal) URL template like <code>/orders/{customerId}</code>, so that the example URL <code>http://foo.ploeh.dk/orders/1234</code> is the address of the order history for customer <em>1234</em>. However, in version 2 of your API, you realize that this way of thinking is still too RPC-like, and you'd rather prefer <code>/customers/{customerId}/orders</code>, e.g. <code>http://foo.ploeh.dk/customers/1234/orders</code>.
	</p>
	<p>
		With a level 3 RESTful API, you can change your internal URL templates, and as long as you keep providing links, clients following links will not notice the difference. However, if clients are 'hacking' your URLs, their applications may stop working if you change URL templates.
	</p>
	<h3 id="a8c7931812ae45b1abecb4ab1e175552">
		Keep clients safe <a href="#a8c7931812ae45b1abecb4ab1e175552" title="permalink">#</a>
	</h3>
	<p>
		In the end, HATEOAS is about encapsulation: make it easy for the client to do the right thing, and make it hard for the client to do the wrong thing. Following links will make clients more robust, because they will be able to handle changes in the API. Making it easy for clients to follow links is one side of designing a good API, but the other side is important too: make it difficult for clients to <em>not</em> follow links: make it difficult for clients to 'hack' URLs.
	</p>
	<p>
		The services I've helped design so far are level 3 APIs, but they still used hackable URLs. One reason for that was that this is the default in the implementation platform we used (<a href="http://www.asp.net/web-api">ASP.NET Web API</a>); another reason was that I thought it would be easier for me and the rest of the development team if the URLs were human-readable. Today, I think this decision was a mistake.
	</p>
	<p>
		What's the harm of supplying human-readable URLs for a level 3 RESTful API? After all, if a client only follows links, the values of the URLs shouldn't matter.
	</p>
	<p>
		Indeed, <em>if</em> the client only follows links. However, clients are created by human developers, and humans often take the road of least resistance. While there are long-time benefits (robustness) from following links, it <em>is</em> more work in the short term. The API team and I repeatedly experienced that the developers consuming our APIs had 'hacked' our URLs; when we changed our URL templates, their clients broke and they complained. Even though we had tried to explicitly tell them that they <em>must</em> follow links, they didn't. While we <em>never</em> documented our URL templates, they were simply too easy to guess from pure extrapolation.
	</p>
	<h3 id="c5eaa6a7456e44ffbb4b6139fe35544f">
		Opaque URLs <a href="#c5eaa6a7456e44ffbb4b6139fe35544f" title="permalink">#</a>
	</h3>
	<p>
		In the future, I plan to make URLs opaque when building level 3 APIs. Instead of <code>http://foo.ploeh.dk/customers/1234/orders</code>, I'm going to make it <code>http://foo.ploeh.dk/DC884298C70C41798ABE9052DC69CAEE</code>, and instead of <code>http://foo.ploeh.dk/products/2345</code>, I'm going to make it <code>http://foo.ploeh.dk/598CB0CAC30646E1BB768596BFE91F2C</code>, and so on.
	</p>
	<p>
		Obviously, that means that my API will have to maintain some sort of two-way lookup table that can map DC884298C70C41798ABE9052DC69CAEE to a request for customer <em>1234</em>'s orders, 598CB0CAC30646E1BB768596BFE91F2C to request for product <em>2345</em>, but that's trivial to implement.
	</p>
	<p>
		It puts a small burden on the server(s), but effectively stops client developers from shooting themselves in their feet.
	</p>
	<h3 id="36fdc650cfb94a3890bcc76d65126ae2">
		Summary <a href="#36fdc650cfb94a3890bcc76d65126ae2" title="permalink">#</a>
	</h3>
	<p>
		Hackable URLs are a good idea if you are building a web site, or a level 1 or 2 REST API, but unless you know that all client developers are enthusiastic RESTafarians, consider producing opaque URLs for level 3 REST APIs.
	</p>
</div>

<div id="comments">
<hr>
<h2 id="comments-header">Comments</h2>
	<div class="comment" id="8ab08a62714148df99c9221240e0f597">
		<div class="comment-author">
			<a href="https://github.com/JontyMC">Jon Curtis</a>
		</div>
		<div class="comment-content">
			<p>
				I understand the benefits of the idea that clients must follow links, I just can't see how it would work in reality. Say you are building a website to display products and you are consuming a rest API, how do you support deep linking to individual products? OK, you can either use the same URL as the underlying API or encode it in, but what are you expected to do if the API changes it's links? Redirect the user to your home page? What if you want to display information from 2 or more resources on the same webpage?
			</p>
		</div>
		<div class="comment-date">2013-05-15 8:04 UTC</div>
	</div>
	<div class="comment" id="040e0e25a60a4ae4873c44af2c01725c">
		<div class="comment-author">
			<a href="/">Mark Seemann</a>
		</div>
		<div class="comment-content">
			<p>
				First of all, keep in mind that while it can be helpful to think about REST design principles in terms of "how would I design this if it was a web site", a REST API is <em>not</em> a web site.
			</p>
			<p>
				You can do deep linking in your web site, but why would you want to do 'deep linking' for an API? These are two different concerns.
			</p>
			<p>
				It's very common to create a web site where each page calls many individual services. This can be done either from the web server (e.g. from ASP.NET or similar), or from the browser as AJAX calls. This is commonly known as <em>mash-up architecture</em>, because the GUI is really just a mash-up of service data. Amazon.com works that way. You can still deep link to a web page; it's the web page's responsibility to figure out which services to call with what parameters.
			</p>
			<p>
				That said, as described in the <a href="http://amzn.to/YFnkRg">RESTful Web Services Cookbook</a>, you should serve <a href="http://www.w3.org/Provider/Style/URI.html">cool URLs</a>, so if you ever decide to change your internal URI template, you should leave a <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.2">301 (Moved Permanently)</a> behind at the old URL. This would enable a client that once bookmarked a resource to follow the redirect to the new address.
			</p>
		</div>
		<div class="comment-date">2013-05-15 9:11 UTC</div>
	</div>
	<div class="comment" id="5c2ee152117c40e7bd37f3e1f003dabe">
		<div class="comment-author">
			<a href="https://github.com/JontyMC">Jon Curtis</a>
		</div>
		<div class="comment-content">
			<p>
				When you say "it's the web page's responsibility to figure out which services to call", that's what I'm getting at, how would the client do that?
			</p>
			<p>
				I'm guessing one way would be to cache links followed and update them on 301s or "re-follow" on 404s. So, say you wanted a web page displaying "product/24", you might:
			</p>
			<ul>
				<li>GET the REST endpoint</li>
				<li>GET product catalogue URL from response</li>
				<li>GET product URL from response</li>
				<li>Cache the product URL against the website product URL</li>
				<li>Subsequent requests hit the cached URL</li>
			</ul>
			<p>
				Then if the product URL changes, if the response is 301, you simply update the cache. If the response is 404 then you'd redo the above steps.
			</p>
			<p>
				I'm just thinking this through, is the above a "standard" approach for creating rest clients?
			</p>
		</div>
		<div class="comment-date">2013-05-15 12:04 UTC</div>
	</div>	
	<div class="comment" id="2189b527e13540daa9382f9db13ecb79">
		<div class="comment-author">
			<a href="/">Mark Seemann</a>
		</div>
		<div class="comment-content">
			<p>
				That sounds like one way of doing it. I don't think there's a 'standard' way for creating RESTful clients.
			</p>
			<p>
				The sketch you paint sounds like a lot of work, and it <em>seems</em> that it would be easier if the client could simply assemble appropriate URLs from templates. That would indicate level 1 and 2 REST APIs, which might be perfectly fine if the only purpose of building the service is to support a GUI. However, what you get in exchange for the extra effort it takes to consume a level 3 API, is better decoupling. It's always going to be a trade-off.
			</p>
			<p>
				It's definitely going to be more work to build and consume a truly HATEOAS-based API, so you should only do it if it's going to provide a good return on investment. When would that be? One general scenario I can think of is when you're building a service, which is going to be consumed by multiple (unknown) clients. If you control the service, but not the clients, I'd say a level 3 API is very beneficial, because it enables you to evolve the API independently of the clients. Conversely, if the only purpose of building a service is to support a single client, it's probably going to be overkill.
			</p>
		</div>
		<div class="comment-date">2013-05-15 15:15 UTC</div>
	</div>
	<div class="comment" id="0716c6ea626247edbea745eb56af01ec">
		<div class="comment-author">
			<a href="https://github.com/redben">Reda Bendiar</a>
		</div>
		<div class="comment-content">
			<p>
				The way I see it is that being HATEOAS compliant does not impose non-hackable URLs, but that URLs - even if they might look hackable (/1, /2...etc) - are not guaranteed to work, are not part of the contract and thus should not be relied uppon. In other words, a link is only guaranteed to work if you, the client, got it from a previous reponse, be it "hackable-looking" or not.
			</p>
			<p>
				So I think opaque URLs are just a way to inforce that contract. But don't we always here that "a good REST client should be well behaved" ?
			</p>
		</div>
		<div class="comment-date">2014-10-10 11:11 UTC</div>
	</div>
	<div class="comment" id="af28eac44f0142db86b1a914ddf21449">
		<div class="comment-author">
			<a href="/">Mark Seemann</a>
		</div>
		<div class="comment-content">
			<p>
				Reda, thank you for writing. You're right, and if we could rely on all clients to be well-behaved, there'd be no problems. However, in my experience, client developers often don't read the documentation particularly thoroughly. Instead, they look at the returned data and start inferring the URL scheme from examples. I already wrote about this in this post:
				<blockquote>"The API team and I repeatedly experienced that the developers consuming our APIs had 'hacked' our URLs; when we changed our URL templates, their clients broke and they complained. Even though we had tried to explicitly tell them that they <em>must</em> follow links, they didn't."</blockquote>
				So, in this imperfect world, non-hackable URLs start to look attractive, because then the client developers have no choice but to follow the links.
			</p>
		</div>
		<div class="comment-date">2014-10-10 12:02 UTC</div>
	</div>
	<div class="comment" id="2f4695ce7e0a4a048ff89760ca2c2916">
		<div class="comment-author">
			<a href="http://kijanawoodard.com/">Kijana Woodard</a>
		</div>
		<div class="comment-content">
			<p>
				I'd like to propose an alternate strategy to achieve the desired result while maintaining 
				the ability to easily debug production issues at the client: 
				only use the non-hackable urls for the "dev sandbox".
			</p>	
			<p>
				Another inducement to better client behvior might be to have the getting started documentation
				use existing libraries for the chosen hypermedia media type.
			</p>	
			<p>
				Finally, have the clients send a "developer [org] identifier". Find a way to probe clients for 
				correctness. For instance, occasionally alter hrefs, but also support the "hackable" form.
			</p>	
			<p>
				With this data, be proactive about informing the user that
				"we're planning a release and your app will probably break because 
				you're not following links as expected".
			</p>
			<p>
				In the end, some people will still fail and be angry. With opaque urls, I would worry that users 
				would have a hard time communicating production issues when looking at logs /fiddler / browser tools / etc.
			</p>
		</div>
		<div class="comment-date">2014-12-23 17:40 UTC</div>
	</div>
	<div class="comment" id="f9d2c7808ffc4f47b5c5b1c8995e7b81">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Kijana, thank you for writing. You suggest various good ideas that I'll have to keep in mind. Not all of them are universally applicable, but then I also don't think that my suggestion should be applied indiscriminately.
			</p>
			<p>
				Your first suggestion assumes that there <em>is</em> a dev sandbox; this may or may not be the case. The APIs with which I currently work have no dev sandboxes.
			</p>
			<p>
				The idea about using existing client libraries for the chosen hypermedia type is only possible if such libraries exist. The APIs I currently design use vendor media types, so client libraries only exist if we develop them ourselves. However, one of the important goals of RESTful services is to ensure interoperability, so we can't assume that clients are going to run on .NET, or Java, or Ruby, or whatever. For vendor media types, I don't think this is a viable option.
			</p>
			<p>
				Using a client identifier is an option, but in order to work well, there must be some way to correlate that identifier to a contact in the client's organisation. That's an option if you already have a mechanism in place where you only allow known clients to access your API. On the other hand, if you publish a truly scalable public API, you may not want to do that, as registration requirements tend to hurt adoption. The APIs I currently work with is a mix of both of those; some are publicly accessible, while others require a 'client key'.
			</p>
			<p>
				These are all interesting ideas, but ultimately, I'm not sure I understand your concern. Let's first establish that 'users' are other <em>programmers</em>. Why would a URL like <code>http://foo.ploeh.dk/DC884298C70C41798ABE9052DC69CAEE</code> be harder to communicate than <code>http://foo.ploeh.dk/customers/1234/orders</code>? Isn't it copy and paste in both cases?
			</p>
			<p>
				To be clear: I don't claim that obfuscated URLs don't make client developers' work more difficult; it does, compared to 'cheating' by hacking the URL schemes, instead of following links. Even for well-behaved client developers, another level of abstraction always makes things harder. On the other hand, this should also make clients more robust, so as always, it's a trade-off.
			</p>
		</div>
		<div class="comment-date">2015-01-22 08:55 UTC</div>
	</div>
	<div class="comment" id="424bd3f6199e422c8294e300d312ffb4">
		<div class="comment-author"><a href="https://twitter.com/dkubb">Dan Kubb</a></div>
		<div class="comment-content">
			<p>
				<blockquote>&ldquo;The API team and I repeatedly experienced that the developers consuming our APIs had 'hacked' our URLs; when we changed our URL templates, their clients broke and they complained. Even though we had tried to explicitly tell them that they <em>must</em> follow links, they didn't.&rdquo;</blockquote>
			</p>
			<p>
				I recently worked on an API for an iOS app and we ran into the same problem. It didn't matter how often I said "these URLs are probably going to change, don't hard-code them into the app" we still ran into issues. This was an internal team, I can only imagine how much more difficult it would be with an external team.
			</p>
			<p>	
				Instead of hashing the URLs, we changed the server-side URL generation to HMAC the URL and append the signature onto the query string. Requests without a valid signature would return a 403 Forbidden response. The root of the domain is the only URL that doesn't require a signature, and it returns a json response with signed URLs for each of the "base" resources.
			</p>
			<p>
				We enabled this on a staging server and since all dev was happening on it, all the hard-coded URLs stopped functioning and were quickly removed from the application. It forced both us and the iOS developers to think more about navigation between resources, since it was impossible to get from one resource to another without valid URLs included in the json responses. I think it was probably also nicer for debugging than hashed URLs would be.
			</p>
		</div>
		<div class="comment-date">2015-04-11 09:26 UTC</div>
	</div>
	<div class="comment" id="29732957a881422ab7d4a38302b7bb5b">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Dan, thank you for sharing that great idea! That looks like a much better solution than my original suggestion of obscuring the URL, because the URL is still human-readable, and thus probably still easier to troubleshoot for developers.
			</p>
			<p>
				Your suggestion also doesn't require a lookup table. My suggested solution would require a lookup table in order to understand what each obscured URL actually <em>means</em>, and if you're running on multiple servers, that lookup table would have to be kept consistent across all servers, which can be hard to do in itself (you can use a database, but then you'd have a single point of failure). Your solution doesn't need any of that; it only requires that the HMAC key is the same on all servers.
			</p>
			<p>
				The only disadvantage that I can think of is that you may need to keep that HMAC key secret, particularly in internal projects, in order to prevent clients from (literally) hacking the URLs.
			</p>
			<p>
				Still, it sounds like your solution has more advantages, so I'm going to try that approach next time. Thank you for sharing!
			</p>
		</div>
		<div class="comment-date">2015-04-11 10:21 UTC</div>
	</div>
	<div class="comment" id="de1db0848da54b399d9af5d8005df0a8">
		<div class="comment-author"><a href="https://twitter.com/dkubb">Dan Kubb</a></div>
		<div class="comment-content">
			<p>
				<blockquote>&ldquo;The only disadvantage that I can think of is that you may need to keep that HMAC key secret, particularly in internal projects, in order to prevent clients from (literally) hacking the URLs.&rdquo;</blockquote>
			</p>
			<p>
				That was one concern of ours too. One approach we considered was including the git commit SHA as part of the HMAC secret so that every commit would invalidate existing URLs. We decided against it because we were doing Continous Delivery, so multiple times a day we were deploying to the server, and we didn't want the communication overhead of having to notify everyone on each commit. We wanted to be able to merge feature branches into master and just know the CI server was going to handle deployment; and that unless we got alerts from CI, Pingdom or New Relic, everything is working as expected. The last thing we wanted to do was babysit the build so we could tell everyone "ok, the new build has deployed to staging, URLs will break so restart any clients you are in the middle of testing". Also part of the reason we use REST (and json-api) was to decouple front and backend development, it seemed counterproductive to introduce coupling <em>back</em> into the process.
			</p>
			<p>
				An internal team could still re-implement this whole mechanism and sign their own URLs. We could either generate random secrets every day or have a simple tool that we can use to change the secret at-will (probably both).
			</p>
			<p>
				Even though it doesn't completely stop URL hard coding, another idea we had was to include an expiration timestamp in the query string and then HMAC the URL with the timestamp included. We would use the responses' Cache-Control max-age to calculate the time, which would allow the client to use any URLs from cached responses. If the client didn't implement proper cache invalidation the URLs would inexplicably break, thus having a nice side-effect of forcing the client to handle Cache-Control max-age properly.
			</p>
		</div>
		<div class="comment-date">2015-04-11 17:58 UTC</div>
	</div>
	<div class="comment" id="f440013aac7842ceb64c94868a500073">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Dan, there are lots of interesting ideas there. What I assumed from your first comment is that you'd calculate the HMAC using asymmetric encryption, which would mean that unless clients have the server's encryption key, they wouldn't be able to recalculate the HMAC, and that would effectively prevent them from attempting to 'guess' URLs instead of following links.
			</p>
			<p>
				If an external client has the server's encryption key, you have a different sort of problem.
			</p>
			<p>
				However, for internal clients, developers may actually be able to find the key in your source control repository, build server, or wherever else you keep it (depending on the size of your organisation). You can solve this with security measures, like ACL-based security on the crypto key itself. It not hard, but it's something you may explicitly have to do.
			</p>
			<p>
				When it comes to tying the URL to cache invalidation, that makes me a bit uneasy. While RESTful clients should follow links, they are allowed to <em>bookmark</em> links. It's a fundamental tenet of proper web design (not only REST) that <a href="http://www.w3.org/Provider/Style/URI">cool URIs don't change</a>. A client should be allowed to keep a particular URL around <em>forever</em>, and a service following <a href="http://en.wikipedia.org/wiki/Robustness_principle">Postel's law</a> should keep honouring requests for that URL. As the <a href="http://amzn.to/YFnkRg">RESTful Web Services Cookbook</a> explains, if you move the resource, you should at least return a 301 (Moved Permanently) "or, in rare cases," issue a 410 (Gone) response.
			</p>
		</div>
		<div class="comment-date">2015-04-12 11:35 UTC</div>
	</div>
	<div class="comment" id="32f5ba2d11f94ec6ad9338b70ea9bd62">
		<div class="comment-author">Sandro Magi</div>
		<div class="comment-content">
			<p>As Dan said, you can use an HMAC to protect certain parameters in a URL from tampering. I actually formalized this approach in a .NET library I call <a href="https://higherlogics-trac.sourcerepo.com/higherlogics_clavis/wiki/WikiStart">Clavis</a>, and which I first discussed in detail <a href="http://higherlogics.blogspot.ca/2014/01/clavis-rebooted-secure-type-safe-urls.html">here</a>.</p>
			<p>Clavis just provides a simple framework for declaring a resources parameter interface. Given that interface, Clavis provides a way to generate URLs when given a valid set of parameters, and also provides a way to safely parse values given a constructed URL. Arbitrary types can be specified as resource parameters, and there's very little boilerplate to convert to/from strings.</p>
			<p>Parameters are protected from tampering by default, but you can declare that some are unprotected, meaning the client can change them without triggering a server validation error. You want this in some cases, for instance to support GET forms, like a search.</p>
		</div>
		<div class="comment-date">2015-04-12 12:16 UTC</div>
	</div>
	<div class="comment" id="fdc20e7cf3e0496bade367ca741b7e58">
		<div class="comment-author"><a href="http://ruben.verborgh.org">Ruben Verborgh</a></div>
		<div class="comment-content">
			<p>Late to the party, but I wonder how you will create a hypermedia form that generates <code>http://foo.ploeh.dk/598CB0CAC30646E1BB768596BFE91F2C</code> rather than <code>http://foo.ploeh.dk/products/2345</code>.</p>
			<p>In the case of hyperlinks, I fully agree: linking to a product should not require an specifically structured identifier. However, hypermedia is more than links alone: what if the client wants to navigate to product with a given tracking number, or a list of people with a given first name?</p>
			<p>“Hackable URIs” are not a <em>necessity</em> for REST, but they are a potential/likely consequence of hypermedia forms. Such forms can be described with less expressive power if only simple string replacements are required instead of more complex transformations.</p>
		</div>
		<div class="comment-date">2016-02-25 11:20 UTC</div>
	</div>
	<div class="comment" id="e15484b5fc4c447e9601ee574a2c8452">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Ruben, thank you for writing. This is a commonly occuring requirement, particularly when searching for particular resources, and I usually solve it with URI templates, as outlined in the <a href="http://amzn.to/YFnkRg">RESTful Web Services Cookbook</a>. Essentially, it involves providing URI templates like <code>http://foo.ploeh.dk/0D89C19343DA4ED985A492DA1A8CDC53/{term}</code>, and making sure that each template is served like a link, with a particular relationship type. For example:
			</p>
			<p>
				<pre><span style="color:blue;">&lt;</span><span style="color:#a31515;">home</span><span style="color:blue;">&nbsp;</span><span style="color:red;">xmlns</span><span style="color:blue;">=</span>&quot;<span style="color:blue;">http://fnaah.ploeh.dk/productcatalog/2013/05</span>&quot;<span style="color:blue;">&gt;</span>
<span style="color:blue;">&nbsp;&nbsp;&lt;</span><span style="color:#a31515;">link-template</span><span style="color:blue;">&nbsp;</span><span style="color:red;">href</span><span style="color:blue;">=</span>&quot;<span style="color:blue;">http://foo.ploeh.dk/0D89C19343DA4ED985A492DA1A8CDC53/{term}</span>&quot;
<span style="color:blue;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:red;">rel</span><span style="color:blue;">=</span>&quot;<span style="color:blue;">http://catalog.api.ploeh.dk/docs/rels/product/search</span>&quot;<span style="color:blue;">&nbsp;/&gt;</span>
<span style="color:blue;">&lt;/</span><span style="color:#a31515;">home</span><span style="color:blue;">&gt;</span></pre>				
			</p>
			<p>
				It isn't perfect, but the best I've been able to come up with, and it works fairly well in practice.
			</p>
		</div>
		<div class="comment-date">2016-03-02 19:25 UTC</div>
	</div>
	<div class="comment" id="cde9b060dba24876a967a00379fc15eb">
		<div class="comment-author"><a href="http://ruben.verborgh.org">Ruben Verborgh</a></div>
		<div class="comment-content">
			<p>
				Sure, URI templates are a means for creating hypermedia controls. But the point is that what they generate are hackable URIs.
			</p>
			<p>
				You still have a (semi-)hackable URI with <code>http://foo.ploeh.dk/0D89C19343DA4ED985A492DA1A8CDC53/{term}</code>. Even though the <code>/0D89C19343DA4ED985A492DA1A8CDC53/</code> part is non-manipulable, terms can still be changed at the end. This shows that hackable URIs cannot entirely be avoided if we want to keep hypermedia controls simple. What else are hackable URIs but underspecified, out-of-band hypermedia controls?
			</p>
			<p>
				An in-band IRI template makes the message follow the REST style by putting the control inside of the message, but it results in a hackable IRI. So, apparently, an HTTP REST API without hackable URIs is hard when there's more than just links.
			</p>
		</div>
		<div class="comment-date">2016-03-02 19:45 UTC</div>
	</div>	
	<div class="comment" id="9fb5c6438480482c800f14f69e9b3c2d">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Ruben, it's not that you can't avoid hackable URLs. URI templates are an optimisation that you can opt to apply, but you don't have to use them. As with so many other architecture decisions, it's a trade-off.
			</p>
			<p>
				When considering RESTful API design, it often helps to ask yourself: <em>how would a web site running in a browser work?</em> You don't have to copy web site mechanics one-to-one (for one, browsers utilise only GET and POST), but you can often get inspiration.
			</p>
			<p>
				A feature like <em>search</em> is, in my experience, one of the clearest cases for URI templates, so let's consider other designs. How does <em>search</em> work on a web site? It works by asking the user to type the search term into a form, and then submitting this form to the server.
			</p>
			<p>
				You can do the same with a RESTful design. When a client wishes to search, it'll have to perform an HTTP POST request with a well-formed request body containing the search term(s):
			</p>
			<p>
				<pre>POST /108B618F06644379879B9F2FEA1CAE92 HTTP/1.1
Content-Type: application/json
Accept: application/json

{ "term": "chocolate" }</pre>
			</p>
			<p>
				The response can either contain the search hits, or a link to a resource containing the hits.
			</p>
			<p>
				Both options have potential drawbacks. If you return the search results in the response to the POST request, the client immediately receives the results, but you've lost the ability to cache them.
			</p>
			<p>
				<pre>HTTP/1.1 200 OK
Content-Type: application/json

{
  "term": "chocolate",
  "results": [{
    "name": "Valrhona",
    "link": {
      "href": "http://example.com/B69AD9193F6E472AB75D8EBD97331E22",
      "rel": "product"
  }
  }, {
    "name": "Friis-Holm",
    "link": {
      "href": "http://example.com/3C4BEC72BFB54E1B8FADB16CCB3E7A67",
      "rel": "product"
    }
  }]
}</pre>
			</p>
			<p>
				On the other hand, if the POST response only replies with a link to the search result, the search results themselves are cacheable, but now the client has to perform an extra request.
			</p>
			<p>
				<pre>HTTP/1.1 303 See Other
Location: http://example.com/0D25692DE79B4AF9A73F128554A9119E</pre>
			</p>
			<p>
				In both cases, though, you'll need to document the valid representations that a client can POST to the search resource, which means that you need to <a href="/2015/06/22/rest-implies-content-negotiation">consider backwards compatibility if you want to change things</a>, and so on. In other words, you can 'protect' the URL schema of the search resource, but not the payload schema.
			</p>
			<p>
				If you're already exposing an API over HTTPS, caching is of marginal relevance anyway, so you may decide to use the first POST option outlined above. Sometimes, however, performance is more important than transport security. As an example, I once wrote (for a client) a publicly available music catalogue API. This API isn't protected, because the data isn't secret, and it has to be fast. Resources are cached for 6 hours, so if you're searching for something popular (say, <em>Rihanna</em>), odds are that you're going to get a response from an intermediary cache. URI templates work well in this scenario, but it's a deliberate performance optimisation.
			</p>
		</div>
		<div class="comment-date">2016-03-10 07:34 UTC</div>
	</div>

  	<div class="comment" id="3208d3ec858e4b9496689b8d72b0f3f6">
		<div class="comment-author"><a href="http://ruben.verborgh.org">Ruben Verborgh</a></div>
		<div class="comment-content">
			<p>
        One can always avoid hackable URLs with trickery, but would you say that leads to a cleaner solution? I agree that search is “one of the clearest cases for URI templates”, so why bother putting in an unneeded <code>POST</code> request just to avoid hackable URIs? I fail to see why this would be a better REST design, given that you loose the beneficial properties of the uniform interface constraints by overloading the <code>POST</code> method for what is essentially a read-only operation. The trade-off here is entirely non-technical: you trade the performance of the interface for the aesthetics of its URLs.
			</p>
			<p>
        Here's how a website would do it: it would have an HTML form for a <code>GET</code> request, which would naturally lead to a hackable URL. Because that's how HTML forms work: like URI templates, they result in hackable URLs. It's unavoidable. Hackable URLs are a direct consequence of common hypermedia controls, which are a necessity to realize the hypermedia constraint. You can swim against the current and make more difficult hypermedia controls, but to whose benefit? It's much easier to just accept that hackability is a side-effect of HTML forms and URI templates.
			</p>
			<p>
        Therefore, your thesis that one should avoid hackable URIs breaks down at this point. APIs with non-hackable URIs are inherently incompatible with URI templates—and why throw away this excellent means of affordance? After all, the most straightforward way to realize search functionality is with an in-band URI template. And URI templates lead to hackable URIs. Hence, hackable URIs occur in REST APIs. You can work around this, but it's quite artificial to do so. In essence, you're using the <code>POST</code> request to obfuscate the URI; having such a translation step for purely aesthetic motives complicates the API and sacrifices caching for no good reason. Hackable URIs are definitely the lesser evil of the two.
			</p>
			<p>
        So, would you avoid hackable URIs at any cost? Or can you agree that they indeed have a place if we like to keep using the hypermedia controls that have been standardized?
			</p>
		</div>
		<div class="comment-date">2016-03-10 23:50 UTC</div>
	</div>
	<div class="comment" id="43f1a970bc3749f383d077aecf5c7195">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Ruben, my intent with this post was to highlight a problem I've experienced when publishing REST APIs, and that I've attempted to explain in the section titled <em>Keep clients safe</em>. I wish that problem didn't exist, but in my experience, it does. It most likely depends on a lot of factors, so if you don't have that problem, you can disregard the entire article.
			</p>
			<p>
				The issue isn't that I want to make URLs opaque. The real issue at stake is that I want clients to follow links, because it gives me options to evolve the API. Consider the example in <a href="/2014/01/20/rest-efficiency">this article</a>. If a client wants to see a user's messages, it should follow links. If, however, a client developer writes the code in such a way that it'll explicitly look for a <code>root &gt; users &gt; user details &gt; user messages</code> route, little is gained.
			</p>
			<p>
				A client looking for user messages should be implemented with a prioritised <em>rule set:</em>
				<ol>
					<li>Look for a <code>user-messages</code> link. If found, follow it. Done.</li>
					<li>Look for a <code>user-details</code> link. If found, follow it, and apply this rule list again from the top.</li>
					<li>Look for a <code>user</code> link. If found, follow it, and apply this rule list again from the top.</li>
				</ol>
				Actually, it's more complex than outlined here, because the rule set may have to dynamically change based on the context, but I hope it gets the main point across.
			</p>
			<p>
				If client developers can guess, and thereby 'hack', my service's URLs, I can't restructure my API. It's not really a question of aesthetics; it's not that I want to be able to <em>rename</em> URLs. The real issue is that sometimes, when developing software, you discover that you've modelled a concept the wrong way. Perhaps you've conflated two concepts that ought to be treated as separate resources. Perhaps you've create a false distinction, but now you realise that two concepts that you thought were separate, is really the same. Therefore, sometimes you want to split one type of resource into two, or more, or you want to combine two or more different types of resources into one.
			</p>
			<p>
				If clients follow links, you have a chance to pull off such radical restructuring. If clients have hard-coded URLs, you're out of luck.
			</p>
		</div>
		<div class="comment-date">2016-03-12 16:28 UTC</div>
	</div>
	<div class="comment" id="0efaa2e9cfc54586801d1f39b5a07386">
		<div class="comment-author"><a href="https://au.linkedin.com/in/ashleyaitken">Ashley Aitken</a></div>
		<div class="comment-content">
			<p>
				Thank you for an interesting post and discussion.  I am no expert wrt REST but I have a comment
				(posed as a question) and a question.
			</p>
			<p>
				If client developers abuse transparent URLs (that are provided in a level 3 api) 
				isn't the fact that the client stops working when the URLs change their problem?
				And sure, they can guess other URLs, just like in the browser we can guess other
				pages. Doesn't mean the application stage should let them access those pages etc.
			</p>
			<p>
				And now the question.  Are there any libraries or tools that allow REST client 
				applications to easily get a list of the links and "follow the links" (i.e. do 
				an API call)?  I can see a client having slots for possible / expected links, 
				filling those that exist, and calling them. Is there any library to help this?
			</p>
		</div>
		<div class="comment-date">2016-06-23 15:18 UTC</div>
	</div>
	<div class="comment" id="98a9a27d3ada47948cc3b2ebf41ac348">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Ashley, thank you for writing. In the end, as you point out, it's the client's problem if they don't adhere to the contract. In some scenarios, that's the end of the story. In other scenarios (e.g. the ones I often find myself in), there's a major client that has a lot of clout, and if those developers find that you've moved their cheese, their default reaction is that it's your fault - not theirs. In such cases, it can be political to ensure that there's no doubt about the contract.
			</p>
			<p>
				I'm not aware of any libraries apart from <a href="https://msdn.microsoft.com/en-us/library/system.net.http.httpclient">HttpClient</a>. It doesn't do any of the things you ask about, because it's too low-level, but at least it enables you to build a sensible client API on top of it.
			</p>
		</div>
		<div class="comment-date">2016-06-23 21:05 UTC</div>
	</div>
</div>
